[{"id":"0b6ba2c8e01bb1370597130d76cb280b","title":"制作一个跑酷系统","content":"1，人物控制和相机控制1：控制相机与角色的偏移transform.position = new Vector3(x,x,x)+ followTarget.position;\n\n2：让相机以角色为中心点，以一个圆为周期转动。\ntransform.position = Quaternion.Euler(x轴转向, y轴转向, 0) * new Vector3(0,0,距离角色距离) \n+ followTarget.position + 中心点的偏移量;\n\ntransform.rotation = Quaternion.Euler(x轴转向, y轴转向, 0)\n\n3：移动和根据相机位置调整方位知识点 : 四元数 * 向量 &#x3D; 旋转后的向量 （注意左右乘）\n//监控按键 0渐变为1或者-1\nfloat h = Input.GetAxis(\"Horizontal\");\nfloat v = Input.GetAxis(\"Vertical\");\n\n//监控按键的量，有值说明有按键\nfloat moveAmount = Mathf.Clamp01(Mathf.Abs(h) + Mathf.Abs(v));\n\n//构建移动向量，注意椭圆映射\nvar moveInput = (new Vector3(\n            h * Mathf.Sqrt(1 - Mathf.Pow(v,2) / 2.0f), \n            0, \n            v * Mathf.Sqrt(1 - Mathf.Pow(h, 2) / 2.0f)));\n\n//获得相机的旋转量 并乘上移动向量，获得旋转后向量\nvar moveDir = cameraController.PlanarRotation * moveInput;\n\n//若有按键\nif (moveAmount > 0) \n        &#123;   //移动\n            transform.position += moveDir * moveSpeed * Time.deltaTime;\n            //保存转动方向\n\t\t\ttargetRotation = Quaternion.LookRotation(moveDir);\n         \n        &#125;\n\n//转动角色朝向\ntransform.rotation= Quaternion.RotateTowards(\ntransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);\n\t\n//设置混合树 \n//dampTime: 用 dampTime 长的时间，将 我们设置的叫做  name 的 float类型 的值由 原本的值 改变到给定的 value 值。\n//deltaTime：两次执行该方法的时间间隔。（因为这个方法会每 deltaTime 执行一次，直到 name = value）\nanimator.SetFloat(Animator.StringToHash(\"NormalAmount\"), moveAmount,0.2f,Time.deltaTime);\n\n\n4：转用CharacterController来控制角色移动CC自带有胶囊碰撞体。一般来说这类东西的组合是Rb+Collider或者单独一个CC。CC适用于第一人称或者第三人称人物角色控制，但是需要自己写一些东西比如重力。\nCharacterController \n1.Character Controller不是基于物理，没有重力，没有阻力，没有加速度，所有移动都是精确的\n\n2.Character Controller可以跨过物体，也就是上台阶，不过会一顿一顿，同是下楼梯需要自己写重力\n\n3.Character Controller 不会对 Rigidbody产生反应\n\n4.Character Controller自带地面监测，不过好像有BUG，一般还是自己写\n\n5.Character Controller的移动通过向量控制，自带碰撞监测\n\nRigidbody\n1.Rigidbody是基于物理的，所以移动会比较平滑自然，但是因为有各种力，所以很难保证精确度\n\n2.Rigidbody会对Rigidbody产生反应\n\n3.Rigidbody的移动通过力或者速度控制，不加碰撞体就不会产生碰撞\n\n\n//transform.position += moveDir * moveSpeed * Time.deltaTime;\n//改成\ncharacterController.Move(moveDir * moveSpeed * Time.deltaTime);\n\n5：使用Physics物理检测检测是否踩在地板上，并且添加重力影响。\n[SerializeField] float groundCheckRadius;\n[SerializeField] Vector3 groundCheckOffset;\n[SerializeField] LayerMask groundLayer;\n[SerializeField] bool isGround;\nGroundCheck(); \n//如果踩在地板上\nif (isGround) \n&#123;\n   ySpeed = -0.5f;\n&#125;else&#123;\n\t//添加一个向下的量，用以模拟重力掉落。\n   ySpeed += Physics.gravity.y ;\n&#125;\nvar velocity = moveDir * moveSpeed;\n\n//添加向下的量\nvelocity.y = ySpeed;\n\n//\ncharacterController.Move(velocity * Time.deltaTime);\n\nprivate void GroundCheck() &#123;\n//射线检测，创建一个球体用来检测\n    isGround = Physics.CheckSphere(transform.TransformPoint(groundCheckOffset) ,\n    groundCheckRadius, \n    groundLayer.value);\n&#125;\n\n\n2.跑酷系统1.墙面扫描设定一个墙面扫描的脚本，用处是扫描人物面前的障碍物。\n对于不同高度的障碍物，需要使用射线扫描面前的障碍物高度，然后根据高度选择播放的动画。\n//前向射线的偏移值\n[SerializeField] Vector3 forwardRayOffset;\n//前向射线长度\n[SerializeField] float forwardRayLength = 0.8f;\n//扫描高度值的射线最大值\n[SerializeField] float heightRayLength = 5f;\n//用于标识障碍物的层\n[SerializeField] LayerMask obstacleLayer;\n\npublic ObstacleHitData ObstacleCheck() \n&#123;\n    var hitData = new ObstacleHitData();\n    var forwardOrigin = transform.position + forwardRayOffset;\n        \n    //前向射线\n    hitData.forwardHitFound = Physics.Raycast(forwardOrigin, \n    transform.forward,\n    out hitData.forwardHit, forwardRayLength,obstacleLayer);\n\n    Debug.DrawRay(forwardOrigin, transform.forward * forwardRayLength,(hitData.forwardHitFound) ?Color.red:Color.white);\n\n    if (hitData.forwardHitFound) &#123;\n        //碰撞点上面往下射,刚好碰到面前物体的边缘,算出障碍物的总高度,需要减去人物最低点才能得到实际高度。\n        var heightOrigin = hitData.forwardHit.point + Vector3.up \n        * heightRayLength;\n\n        hitData.heightHitFound = Physics.Raycast(heightOrigin,Vector3.down,\n        out hitData.heightHit,heightRayLength,obstacleLayer);\n\n        Debug.DrawRay(heightOrigin,Vector3.down * heightRayLength,(hitData.forwardHitFound) ? Color.red : Color.white);\n\n        Debug.Log(hitData.heightHit.point);\n    &#125;\n        return hitData;\n&#125;\n\npublic struct ObstacleHitData &#123;\n    //前向射线是否有碰撞\n    public bool forwardHitFound;\n    //高度射线是否有碰撞\n    public bool heightHitFound;\n    //前向射线\n    public RaycastHit forwardHit;\n    //高度射线\n    public RaycastHit heightHit;\n&#125;\n2.播放动画首先封装一个行为类ParkourAction，继承自ScriptObject，用于存储动画信息和触发动画需要的条件。\n[SerializeField] private  string animName;\n//可播放动画的最低高度\n[SerializeField] private float minHeight;\n//可播放动画的最高高度\n[SerializeField] private float maxHeight;\n\n//是否要角色转向障碍物\n[SerializeField] bool rotateToObstacle;\n\n[Header(\"使用Target Matching\")]\n[SerializeField] bool enabledTargetMatching = true;\n[SerializeField] AvatarTarget matchBodyPart;\n[SerializeField] float matchStartTime;\n[SerializeField] float matchTargetTime;\n\n//存储四元数,里面是射线碰撞到的障碍物的法线方向取反,即角色朝向障碍物面的四元数。\npublic Quaternion TargetRotation &#123; get; set; &#125;\npublic Vector3 MatchPos &#123; get; set; &#125;\n\n//检测条件是否符合播放动画的要求\npublic bool CheckIfPossible(ObstacleHitData hitData, Transform player) &#123;\n    //减去人物的高度得出障碍物的高度\n    float height = hitData.heightHit.point.y - player.position. y;\n    Debug.Log($\"面前的障碍物高度为:&#123;height&#125;\");\n    \n    if (height &lt;= minHeight || height > maxHeight) &#123;\n        return false; \n    &#125;\n\n    if (rotateToObstacle)\n    &#123;\n        \n        TargetRotation = Quaternion.LookRotation(-hitData.forwardHit.normal);\n    &#125;\n       \n    if (enabledTargetMatching) &#123;\n        MatchPos = hitData.heightHit.point;\n    &#125;\n    return true;\n&#125;\n\npublic string AnimName => animName;\npublic bool RotateToObstacle => rotateToObstacle;\n\npublic bool EnabledTargetMatching => enabledTargetMatching;\npublic AvatarTarget MatchBodyPart=> matchBodyPart;\npublic float MatchStartTime => matchStartTime;\npublic float MatchTargetTime => matchTargetTime;\n\n\n对于跨越或者攀爬这种会实际产生模型位移的动画，需要注意Animator的Apply Root Motion和动画Import Setting里Animation的Bake Into Pose，此处需要将Animator组件的Apply Root Motion勾选上。使用协程来执行跨越障碍物的动画，\nIEnumerator DoParkoutAction(ParkourAction action) &#123;\n    //是否在播放动画\n    inAction = true;\n    //角色控制器是否可控\n    playerController.SetControl(false);\n    animator.CrossFade(action.AnimName, 0.1f);\n    //animator.Play(\"StepUp\");\n    yield return null; \n\n    \n    //此函数在过渡期可用,获得下一个动画状态\n    var animState = animator.GetNextAnimatorStateInfo(0);\n    if (!animState.IsName(action.AnimName)) &#123;\n        Debug.Log(\"The parkour animation is wrong\");\n    &#125;\n         \n\n    float timer = 0f;\n    //动画播放中\n    while(timer &lt;= animState.length)\n    &#123;\n        timer += Time.deltaTime;\n\n        if (action.RotateToObstacle) &#123;\n            //转向障碍物\n            transform.rotation = Quaternion.RotateTowards(\n            transform.rotation,\n            action.TargetRotation,\n            playerController.RotationSpeed * Time.deltaTime);\n        &#125;\n\n        //目标匹配,后面再讲\n        if (action.EnabledTargetMatching) &#123;\n            MatchTarget(action);\n        &#125;\n\n        yield return null;\n    &#125;\n\n    //解除锁定\n    inAction = false;\n    playerController.SetControl(true);\n    &#125;\n\n\n3.优化动画出现的问题：\n1.动画在播放结束后，脚部会出现障碍物穿模或者高过障碍物的情况。\n2.有攀墙动作的动画，手部无法真正抓住边缘。\n3.攀爬结束后按前进会导致人物平移一段时间。\n4.攀爬过程中整个人穿模，而且有\nTarget Matching 目标匹配Unity手册的描述：通常在游戏中可能出现以下情况：角色必须以某种方式移动，使得手或脚在某个时间落在某个地方。例如，角色可能需要跳过踏脚石或跳跃并抓住顶梁。这种情况可以用Target Maching。(似乎只能用在AnimatorController里)\n我们的动画里有跃起，然后踏上障碍体的动作。首先要在AnimationClip里找到动画标准化时间的两个点，1个是角色离地的时间点，1个是踏上障碍体,结束落地的时间点。\nvoid MatchTarget(ParkourAction action) &#123;\n    //是否要使用了目标匹配\n    if (animator.isMatchingTarget) &#123;\n        return;\n    &#125;\n\n    //参数解释：1.需要匹配的位置(一般为障碍物的高度值y,这里为高度射线的碰撞点位置取y值)\n    //2.角色转向的四元数。 3.系统枚举值:要匹配的肢体,人物四肢的其中1个。 4.~。 5.开始匹配的时间点。 6.结束匹配的时间点\n    animator.MatchTarget(action.MatchPos,transform.rotation,\n        action.MatchBodyPart,\n        new MatchTargetWeightMask(new Vector3(0,1,1),0),\n        action.MatchStartTime,\n        action.MatchTargetTime);\n    &#125;\n\n第1点，这时候可以调整,调为feet。\n使用 Feet__ 时，对于所有帧，Root Transform Position Y 将与位置最低的脚 Y 匹配。因此，混合点始终保持在脚周围，从而防止在混合或过渡时发生浮动问题。\n脚超模的现象可以按第2点调。\n第2点，需要调整MatchTarget第4个参数，Unity手册里写的是：包含匹配位置和旋转的权重的结构，使用此结构可为 Animator.MatchTarget 指定位置和旋转权重遮罩。\n有一个Vector3类型的参数positionXYZWeight:位置 XYZ 权重,值在0~1之间。\n一个float类型的参数rotationWeight:\t旋转权重\n这里把positionXYZWeight的z值设为最高值1,这样匹配的权重会偏向障碍物平面的最边缘，可以把这个权重值封装在ScriptObject行为类里。同理把y值设为1,说明在匹配y值方面,会把权重偏向最接近障碍物平面上,这样就不容易出现脚穿模在地下的情况。\n第3点，这里有一点上述的代码里没讲，因为攀爬动作没有从蹲下到站立的动画，所以攀爬结束后混合了一段蹲到站立的动画。而这里是由于使用了Time.deltaTime只等待了一段AnimationClip的播放，没有等待蹲下到站立的部分。这段的解决比较宽泛，可以用yield return 再等待一段时间。\n第4点，这个是因为Match Target的匹配时间点没设好，只能慢慢调了。\n未完待续\n","slug":"制作一个跑酷系统","date":"2022-06-26T11:44:10.000Z","categories_index":"Unity","tags_index":"制作实例,动画系统,C#","author_index":"HalfReunion"},{"id":"df72ebc7475da7a2a818b4e6f4f94099","title":"Time函数和Update和FixedUpdate","content":"Time.timeScale 不会影响Update和LateUpdate的执行速度。\nFixedUpdate是根据Time.time来执行的，所以Time.timeScale会影响到FixedUpdate的执行。\nFixedTimeStep中的设置是指Time.time的时间变化，如果设置为0.02s，则意味着Time.timeScale&#x3D;1的情况下，Time.time的值每过0.02秒就调用一次FixedUpdate。\nTime.deltaTime：表示当前时刻到上一帧所经过的秒数，具体值和当前游戏的帧数有关。Time.deltaTime的值在update上 &#x3D; 1&#x2F;帧率 * Time.timeScale。同时也是Time.time的增量值。 \n所以在Update中进行物体移动的话，需要Time.deltaTime * speed * Vector3方向向量,相当于每秒往Vector3方向移动speed距离。\n\nFixedUpdate，固定的一个时间频率去调整； \nUpdate，根据系统性能的FPS速率有影响关系；\n关于上两条的一些证明\npublic void FixedUpdate()\n    &#123;\n        i++;\n        Debug.Log(\"这在是第\" + i + \"帧\");\n        time += Time.deltaTime;\n        Debug.Log(\"时间：\" + time);\n    &#125;\n\n上面的time值始终是以0.02的量去增长。\nvoid FixedUpdate()\n&#123;\n\tDebug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\nvoid Update()\n&#123;\n\tDebug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\n经此测试可发现，在帧率较低的情况下，FixedUpdate并不是间隔0.02秒才调用一次，有可能在Update前调用多次，间隔的时间也不一定，当我们设置FixedUpdate的步长为0.02秒（50FPS）时，设置刷新的频率为30FPS，FixedUpdate每秒的调用次数势必要多于Update。\n[SerializeField]\n float time = 0f;\n [SerializeField]\n float Fixedtime = 0f;\nvoid FixedUpdate()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        Debug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n        Debug.Log(\"FixedUpdate deltaTime: \" + Time.deltaTime);\n        Fixedtime += Time.deltaTime;\n\n    &#125;\n\n    void Update()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        time += Time.deltaTime;\n        \n        Debug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n    &#125;\n\n验证两者对于真实时间的联系，设置游戏帧率为10帧，在经过1秒后，二者的增量几乎一致。\n\n已知，Update的调用次数为1秒钟调用帧数次，FixedUpdate设置的步长为0.02。则1&#x2F;0.02 &#x3D; 50FPS。\n\n所以说FixedUpdate固定时间频率是指，会在1秒内调用 （1&#x2F;设置的步长） 次FixedUpdate，而不一定是经过真实时间里 设置的Fixed Step  秒就调用1次，两次FixedUpdate调用的间隔其实是Time.time经过 设置的步长。\n而Update则是根据游戏内的帧率时刻浮动来决定执行次数。\n所以，FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。\n因为它是用来处理物理模拟的，更重要的是它并非根据真实时间的间隔执行，而只是有一个固定的量。\n关于为何要推荐在FixedUpdate处理物理逻辑：在物理模拟中，保证一个固定的增量时间是十分重要的。这是因为在游戏引擎进行物理模拟时要使用数值积分，而作为最简单的数值积分方法——欧拉法在游戏引擎中大量使用。而在游戏引擎的物理模拟中，一个不稳定的增量时间可能导致很多和预期相悖的结果。\n固定的增量时间作为一个常量参数传递给物理模拟模块，这样我们就能够保证物理模拟的增量时间固定，同时还能将物理模拟的更新频率和游戏引擎的更新频率进行解耦——物理的模拟不受引擎的更新频率影响，无论游戏的更新频率是多少，传递给物理模拟的增量时间都是一个常量。\nOnTrigger，OnCollision系列和FixedUpdate都依赖物理步，也就是Fixed Step来触发。\n而如果将输入检测或者需要每帧检测的逻辑放入物理步中判断就会出错。\n\nTime.timeScale 会影响Time.Time，比如Time.timeScale ＝ 2的话，那么Time.time的增长速度也会变成2倍速度。\n如果你想取到游戏的实际时间，那么使用Time.timeSinceLevelLoad就可以，前提是必须在**Awake()方法以后再取，如果在Awake()**方法里面取Time.realtimeSinceStartup会取出一个错误的值，在Start方法里面取的话就正常了。\n总之一句话Time.timeScale影响的是Unity的游戏时间缩放比例。\nUnity里面所有跟时间有关系的东西都是根据timeScale来演算的。\n仔细想想现在的手游就是个 动画 和 粒子技能特效 还有UI位移特效，所以改他们的速度直接用Time.timeScale就可以完成。还有一个重要的东西就是人物移动 或者 技能移动的速度了，\n 根据时间的公式，时间 ＝ 路程\\速度 ，比如角色从起点跑到中间的一个预期时间， 或者一个技能的火球从攻击到打中目标的预期时间。 凡是处理时间的东东全用Time.time 这样就可以完美让Time.timeScale控制你的游戏了。\n\n有关于LateUpdate的操作，事关摄像机跟随游戏对象时会发生抖动的阐述。\n画面抖动的原因是因为摄像机位置更新与目标(抖动对象)位置更新不同步造成的.\n结论：1）Time.time的每帧的增量即为Time.deltaTime\n2）Time.deltaTime和Time.time都受Time.timeScale影响，且是正比的关系\n3）Time.deltaTime的最大调用时间间隔为Time面板的 Maximum Allowed Timestep 值\n4）Time.realtimeSinceStartup不受Time.timeScale影响，它为真实的游戏时间\n5）Update的调用不受Time.timeScale影响，它的调用间隔和真实的上一帧调用时间有关\n6）LateUpdate的调用同Update，不受Time.timeScale影响（截图时忘了开打印，实际同Update）\n7）FixedUpdate的调用受Time.timeScale影响，且成正比，当Time.timeScale &#x3D; 0时，FixedUpdate不被调用\n8）FixedUpdate的调用时间间隔为Time面板的 Fixed Timestep 值，受Time.time影响。\n\nFixedUpdate在每帧的调用不固定，有可能执行多次，有可能不执行。\n\n总结：1）想让游戏对象受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.time &#x2F; Time.deltaTime 做关联计算并放在Update中更新，或者将它放在FixedUpdate中做更新（使用Time.fixeddeltaTime，或按帧计算）\n2）想让游戏对象不受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.realtimeSinceStartup 做关联计算并放在Update中更新\n3）Unity中默认Animation、Animator和粒子特效都是受Time.timeScale（子弹时间）影响的\n4）想让Animator不受Time.timeScale（子弹时间）影响时，可以将它的更新模式改为：animator.updateMode &#x3D; AnimatorUpdateMode.UnscaledTime;\n5）想让Animation或粒子特效不受Time.timeScale（子弹时间）影响时，要用Time.realtimeSinceStartup做采样计算，并对它们做更新\n\n额外部分内容的链接https://blog.csdn.net/cube454517408/article/details/107496353\n关于Time相关的例子：\n1，子弹时间（缓慢的粒子特效 或者 只有自己不受影响\n2，定时回调系统\n3，暂停游戏\n设置 Time.timeScale ＝ 0；即可让游戏暂停。 其实我们暂停的主要是 人物动画，还有技能特效，比如一个火球打了一半。\nUI方面往往我们不希望暂停，比如暂停界面 有一些UI位移动画或者帧动画， 或者最起码要有个“取消暂停的按钮” 吧。 总不能游戏暂停了我点击按钮，按钮的点击动画或者特效也暂停了吧。\n所有的动画都是基于时间来的，因为Time.timeScale ＝ 0了，所以Time.time也就不会在变化了。换句话来说如果游戏暂停以后想在暂停界面上继续播放一些不受Time.timeScale 影响的动画，那么我们就需要用到Time.realtimeSinceStartup。\nAnimationState animState = animation[clipName]; // 当前动画状态\nanimation.Play(clipName);//播放动画\ncurTime = Time.realtimeSinceStartup; // 当前真实时间\ndeltaTime = curTime - lastFrameTime; // 此帧与上一帧的时间间隔\nlastFrameTime = curTime; // 记录此帧时间，下一帧用\nprogressTime += deltaTime; // 动画已播放时间\nanimState.normalizedTime = progressTime / currState.length; // 动画规范化时间[0-1]\nanimation.Sample(); // 在当前状态对动画进行采样，当你想显式设置动画状态并且对它取样的时候使用\n\n\n附录： 只读:\nTime.time：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。Time.deltaTime：表示从上一帧到当前帧的时间，以秒为单位。Time.unscaleddeltaTime：不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。Time.timeSinceLevelLoad：表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。Time.unscaledTime：不考虑timescale时候与time相同，若timescale被设置，则无效。Time.fixeddeltaTime：表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。Time.realtimeSinceStartup： 表示自游戏开始后的总时间，即使暂停也会不断的增加。Time.frameCount：总帧数\n 可读可写:\nTime.fixedTime：表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixeddeltaTime）直到达到time属性。Time.SmoothdeltaTime：表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。Time.timeScale：时间缩放，默认值为1，若设置&lt;1，表示时间减慢，若设置&gt;1,表示时间加快，可以用来加速和减速游戏，非常有用。Time.captureFramerate：表示设置每秒的帧率，然后不考虑真实时间。 \n\n帧数显示器和设置游戏整体帧率的代码：\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FPS : MonoBehaviour\n&#123;\n    private float m_LastUpdateShowTime = 0f;  //上一次更新帧率的时间;  \n\n    private float m_UpdateShowdeltaTime = 0.01f;//更新帧率的时间间隔;  \n\n    private int m_FrameUpdate = 0;//帧数;  \n\n    private float m_FPS = 0;\n\n    void Awake()\n    &#123;\n\t\t\t\t//设置帧率\n        Application.targetFrameRate = 30;\n    &#125;\n\n    // Use this for initialization  \n    void Start()\n    &#123;\n        m_LastUpdateShowTime = Time.realtimeSinceStartup;\n    &#125;\n\n    // Update is called once per frame  \n    void Update()\n    &#123;\n        m_FrameUpdate++;\n        if (Time.realtimeSinceStartup - m_LastUpdateShowTime >= m_UpdateShowdeltaTime)\n        &#123;\n            m_FPS = m_FrameUpdate / (Time.realtimeSinceStartup - m_LastUpdateShowTime);\n            m_FrameUpdate = 0;\n            m_LastUpdateShowTime = Time.realtimeSinceStartup;\n        &#125;\n    &#125;\n\n    void OnGUI()\n    &#123;\n        GUIStyle labelFont = new GUIStyle();\n        labelFont.fontSize = 20;\n        GUI.Label(new Rect(Screen.width / 2, 0, 100, 100), \"FPS: \" + m_FPS, labelFont);\n    &#125;\n&#125;\n\n关于deltaTime比较粗浅的解释：https://www.cnblogs.com/jiangxiaoming/p/12983807.html\n","slug":"Time函数和Update和FixedUpdate","date":"2022-06-26T08:17:29.000Z","categories_index":"Unity","tags_index":"C#,Api,探索发现","author_index":"HalfReunion"}]