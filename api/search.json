[{"id":"d128f62f62d268410a7ff9276841ac04","title":"玩游戏-仁王2","content":"之前一段时间(半年前)在玩仁王2，实在是很有意思的游戏。有可玩性高的动作系统，换一把武器就能有截然不同体验的感觉和怪猎非常相似，然后还拥有一些刷刷刷，装备build的RPG要素。\n游戏里角色操作三段架势还有数种适配架势的技能，结合精力管控系统，再进行一些合理的玩法增添后，让人玩起来感觉非常顺滑且游刃有余，当然这是建立在偏后期，阴阳术和基本装备成型后才能达到的效果，游戏的前期体验在没有选对武器，加点思想不对的情况下还是非常吃苦（说的就是你，手甲），不过我以前玩过1代，所以对残心的使用还是比较知悉，至少说有使用它的习惯。\n精力系统的存在我认识是对游戏内RPG要素的一个妥协，也可能算是种历史遗留问题，毕竟1代的时候光荣脱裤魔是有些碰瓷宣传的，碰的是目前还在大热的魂系，估计当时组内也是以制作一款类魂游戏为目的去制作，当然了，游戏本身最大的成功还是要归功于忍者组深厚的ACT游戏制作功底，不管怎么说也是经历过忍龙的组，而现在很多类魂3D游戏，也不是每款都像仁王那么独一档。（迸发，堕落之王，Mortal Shell，CODE VEIN等），当然我是认为凭借这套动作系统，完全可以摆脱这套精力系统，去做更自由的变化。\n目前玩的时候是时间是\n\n\n仁王1的进度还在DLC里，还是大学时期玩的，估计是不会再碰。而仁王2在5周目后直接打奈落狱，进度是第30层。\n因为我主用手甲，也没换过武器，所以下面的体验以手甲为主：\n手甲最大的使用体验在于需要你使用不同武技去叠加名为“连绵”的buff，这个buff能增加伤害，因为本身手甲动作发生比较快，所以作为补偿伤害也会相应低一些，所以十分依靠连绵buff带来的伤害补足，也因此叠加连绵层数期间会让人觉得十分拖沓，暖机机制也不是所有人都喜欢。连绵buff最多有10层，且层数越高buff存在的时间就越短，如何快速叠加连绵，且在连绵buff生效期间去打出高伤害，就成为了重中之重的技巧，叠不起buff的话伤害就会非常刮痧，体验极差。由于手甲的动作十分之快，所以在连续攻击的情况下切换架势去释放不同战技，也不会有停顿感，更别说一些战技拥有位移闪避的效果，配合高层数连绵和混沌debuff，打起来还是非常赏心悦目的。\n混沌debuff又是这个游戏里面比较重要的玩法，混沌debuff的效果是增加玩家伤害，和阻止妖怪进入常暗。 这一作的妖怪型敌人在妖力槽被清空前都处于霸体状态，只有在妖力槽清空后玩家攻击才会造成硬直。在妖力槽清空的一段时间后或者妖怪从可处决状态里恢复过来，就会自动进入常暗，特效是玩家所见都变成黑白，玩家精力槽回复变慢，妖怪恢复大部分妖力槽且增加很多招式且保持霸体。若能在妖怪进常暗前让妖怪进入混沌的debuff状态，就能在妖怪倒地处决前不进入常暗。\n混沌debuff需要让对面积累两种异常属性（不包括麻痹和毒），一般来说武器可以附魔增加一种属性，而另一种属性就要依靠阴阳术（类似法术一样的存在）。所以这也是这个游戏里“阴阳武者”这件套装十分风靡的原因，阴阳武者的神宝套装效果，可以恢复玩家最后一次释放的阴阳术的数量，搭配一些强力阴阳术，能让受苦度大量下降。\n当然进入常暗状态对玩家也不是一件完全有害的事，进入常暗后攻击妖怪能大幅度增加自己的妖力槽，而妖力槽是释放妖怪技的必须能量。所以也存在进入常暗后，无限释放妖怪技的build。\n所以现在很期待忍者组的下一部三国题材的作品。\n下一个游戏想玩arc system的ggst。\n","slug":"玩游戏-仁王2","date":"2022-07-04T11:26:58.000Z","categories_index":"随笔","tags_index":"玩游戏","author_index":"HalfReunion"},{"id":"ce2b5aade03ea809a40872ba12728878","title":"ET框架学习_ETBook阅览(慢慢更)","content":"加了ET群很久，一直只是看群里的人聊天谈地，clone了ET框架很长时间，也没有怎么看过，所以这次想先从ETBook开始看起，认识一下这个框架。\nETBook地址:http://etgame.cn/pages/a2f161/\n在这次的ETBook阅读的同时，我也会同步看烟雨迷离半世殇的ETBook笔记汇总，加深理解。\n烟雨迷离半世殇的ETBook笔记汇总：https://www.lfzxb.top/etbook/\n目前的git上的master分支已经更到了7.0，该版本似乎还在持续更新中，不知道有多大的时效性。\n略过前面的介绍，直接从第二章:CSharp的协程开始。\n\n2.CSharp的协程2.1 CSharp的协程作者在开篇使用一段while循环+线程挂起的程序。并以此做延伸来引出异步的实现。\nprivate static void Main()\n   &#123;\n       int loopCount = 0;\n       while (true)\n       &#123;\n           int temp = watcherValue;\n           \n           Thread.Sleep(1);\n           \n           ++loopCount;\n           if (loopCount % 10000 == 0)\n           &#123;\n               Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n           &#125;\n       &#125;\n   &#125;\n为了做出延时5秒后输出loopCount的效果，且不打断10000次计数打印一次的逻辑，这里导入ET框架中的一个自定义单例OneThreadSynchronizationContext，这个类主要处理别的线程扔回主线程的委托。简短介绍一下该类的成员和方法。\n\nOneThreadSynchronizationContext\n\n//SynchronizationContext 提供了1个Post虚函数。\npublic class ThreadSynchronizationContext : SynchronizationContext&#123;\n    // Instance单例访问器\n    public static ThreadSynchronizationContext Instance;       \n\n    // 用于存储主线程的线程ID,在构造函数里初始化\n    private readonly int threadId ;\n    \n    // 线程同步队列,发送接收socket回调都放到该队列,由poll线程统一执行\n    // 一个线程安全的只读队列,存储Action。\n    private readonly ConcurrentQueue&lt;Action> queue;\n\n    //用于存储从队列里提取的Action委托\n    private Action a;\n\n    //一个轮询用的函数,\n    public void Update()&#123;\n        while(true)&#123; \n\n             //此处提取queue里的委托,若无则return;\n            if(!TryDequeue(out a))&#123;\n               \n                return;\n            &#125; \n            //执行Action委托 \n        &#125;\n    &#125;\n\n    //覆写SynchronizationContext的虚函数Post\n    public override void Post(SendOrPostCallback callback, object state)\n    &#123;   //用了一个匿名函数\n        this.Post(() => callback(state));\n    &#125; \n\n    public void Post(Action action)\n    &#123;\n        //首先会判断当前Thread线程的ID是否与此单例的线程ID相同\n        if(xxx)\n        &#123;\n            //若相同,说明目前在主线程,则执行参数action\n            return;\n        &#125; \n\n    //否则将其他线程来的action委托入队queue\n\n    &#125;\n\n    //用于将参数action入队\n    public void PostNext(Action action)\n    &#123;&#125; \n&#125;\n\n\n而后作者设计出了一个异步方法，这个方法核心在于：另开一个线程，并将逻辑包裹成委托传入，使用Thread.Sleep做阻塞n秒的操作，待阻塞完毕后将委托扔回主线程执行，这样就能在不阻塞主线程的情况下作一个计时操作，也避免了一些线程冲突操作，且免去加锁的麻烦。\n\n2.2 更好的协程使用上面的方法如果有增加的需求会不方便。这时候可以用C#自带的异步语法。此处使用了C#设计的几个逻辑\n\nTask\nasync&#x2F;await\nTaskCompletionSource\n\n1.Task可以理解为，为了一个异步操作而封装了多种功能的集合单位，本质还是使用了Thread，MSDN直接解释为一个异步操作。而Thread更倾向于是一个最基本的线程单元。\n2.async&#x2F;await是一对组合使用的关键字，async用于修饰方法，用于提醒该方法里有异步操作，而await用于修饰async方法里的逻辑，await是阻塞的，若无返回则不会执行下面的操作。\n3.TaskCompletionSource，是一种创建Task的方式。集合了控制Task的方法。\nprivate static void WaitTimeAsync(int waitTime, Action action)\n&#123;\n    Thread thread = new Thread(()=>WaitTime(waitTime, action));\n    thread.Start();\n&#125;\n\n//此处把action回调略去,改为使用TaskCompletionSource\nprivate static Task WaitTimeAsync(int waitTime)\n&#123;\n    TaskCompletionSource&lt;bool> tcs = new TaskCompletionSource&lt;bool>();\n    Thread thread = new Thread(()=>WaitTime(waitTime, tcs));\n    thread.Start();\n    return tcs.Task;\n&#125;\n改变了之前需要回调方法里嵌套回调来实现的连续异步操作。\nprivate static async void Crontine()\n&#123;\n    await WaitTimeAsync(5000);\n    Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n    await WaitTimeAsync(4000);\n    Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\"); \n&#125;\n\n//旧的形式\npublic static void main()&#123;\n    WaitTimeAsync(5000, WaitTimeFinishCallback);\n&#125;\n\nprivate static void WaitTimeFinishCallback()\n&#123;\n    Console.WriteLine($\"WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n    WaitTimeAsync(4000, WaitTimeFinishCallback2);\n&#125;\n此时作者在主线程调用了这个静态函数：SynchronizationContext.SetSynchronizationContext(OneThreadSynchronizationContext.Instance); 用于同步上下文，替换了将逻辑扔回主线程执行的操作，\n在WaitTime中直接调用tcs.SetResult(true)就行了，回调会自动扔到同步上下文中，而同步上下文我们可以在主线程中取出回调执行，这样自动能够完成回到主线程的操作\n private static void WaitTime(int waitTime, TaskCompletionSource&lt;bool> tcs)\n&#123;\n    Thread.Sleep(waitTime);\n\n    tcs.SetResult(true);\n&#125;\n\n2.3 单线程异步异步实现不仅仅只有多线程的方式，一般游戏逻辑会设计一个单线程的计时器。代码比较简单,直接贴出来了。\n\n单线程异步\n\nclass Program\n    &#123;\n        private static int loopCount = 0;\n\n        private static long time;\n        private static Action action;\n        \n        static void Main(string[] args)\n        &#123;\n            Console.WriteLine($\"主线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;\");\n\n            Crontine();\n            \n            while (true)\n            &#123;\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                &#123;\n                    Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n                &#125;\n            &#125;\n        &#125;\n        \n        private static void Crontine()\n        &#123;\n            \n            WaitTimeAsync(5000, WaitTimeAsyncCallback1);\n        &#125;\n\n        //每次执行完都会刷新一次time和委托\n        private static void WaitTimeAsyncCallback1()\n        &#123;\n            Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n            \n            //刷新新的time和委托\n            WaitTimeAsync(4000, WaitTimeAsyncCallback2);\n        &#125;\n        \n        \n        private static void CheckTimerOut()\n        &#123;\n            if (time == 0)\n            &#123;\n                return;\n            &#125;\n            // 检测时间到了没有,若到了则执行。\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            &#123;\n                return;\n            &#125;\n\n            time = 0;\n            action.Invoke();\n        &#125;\n        \n        private static void WaitTimeAsync(int waitTime, Action a)\n        &#123;\n             \n            time = DateTime.Now.Ticks / 10000 + waitTime;\n            action = a;\n        &#125;\n    &#125;\n\n\n把上面的样子改成await形式\n\nawait异步\n\nclass Program\n&#123;\n    private static int loopCount = 0;\n\n    private static long time;\n    private static TaskCompletionSource&lt;bool> tcs;\n        \n    static void Main(string[] args)\n    &#123;\n        Console.WriteLine($\"主线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;\");\n\n        Crontine();\n            \n        while (true)\n        &#123;\n            Thread.Sleep(1);\n\n            CheckTimerOut();\n                \n            ++loopCount;\n            if (loopCount % 10000 == 0)\n            &#123;\n                Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n            &#125;\n        &#125;\n    &#125;\n        \n    private static async void Crontine()\n    &#123;\n        await WaitTimeAsync(5000);\n        Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n        await WaitTimeAsync(4000);\n        Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\"); \n    &#125;\n\n    private static void CheckTimerOut()\n    &#123;\n        if (time == 0)\n        &#123;\n            return;\n        &#125;\n        long nowTicks = DateTime.Now.Ticks / 10000;\n        if (time > nowTicks)\n        &#123;\n            return;\n        &#125;\n\n        time = 0;\n        tcs.SetResult(true);\n    &#125;\n        \n    private static Task WaitTimeAsync(int waitTime)\n    &#123;\n        TaskCompletionSource&lt;bool> t = new TaskCompletionSource&lt;bool>();\n        time = DateTime.Now.Ticks / 10000 + waitTime;\n        tcs = t;\n        return t.Task;\n    &#125;\n&#125;\n\n\n\n代码简单，要注意的点是await不会开启多线程，这上面的调用都是在主线程中完成，有没使用多线程取决于具体实现，task在没有await的情况下是非阻塞的。我本身对这个不太熟悉，要去补补对应知识。\n3.2 强大的MongoBson库需要使用序列化的场景:\n\n对象通过序列化反序列化clone\n服务端数据库存储数据，二进制\n分布式服务端，多进程间的消息，二进制\n后端日志，文本格式\n服务端的各种配置文件，文本格式\n\n列举常用序列化库\n\nprotobuf不支持复杂的对象结构(无法使用继承)，做消息合适，做数据库存储和日志格式并不好用。\njson做日志格式合适，但是做网络消息和数据存储就太大。\n\n\n适用场景\n\n\n你想想某天你的配置文件需要放到数据库中保存，你不需要进行格式转换，后端直接把前端发过来的配置消息保存到数据库中，这是不是能减少非常多错误呢？\n某天有些服务端的配置文件不用文件格式了，需要放在数据库中，同样，只需要几行代码就可以完成迁移。\n某天后端服务器crash，你需要扫描日志进行数据恢复，把日志进行反序列化成C#对象，一条条进行处理，再转成对象保存到数据库就完成了。\n对象保存在数据库，直接就可以看到文本内容，可以做各种类sql的操作\n想像一个场景，一个配置文本对象，反序列化到内存，通过网络消息发送，存储到数据库中。整个过程一气呵成。、\n\n\n这里作者选用了Mongo Bson，可以减少各种数据转换，减少代码，提高可维护性。MongoDB库既可以序列化成文本也可以序列化成BSON的二进制格式。\n\nMongo Bson支持功能\n\n\n支持复杂的继承结构\n支持忽略某些字段序列化\n支持字段默认值\n结构多出多余的字段照样可以反序列化，这对多版本协议非常有用\n支持ISupportInitialize接口使用，这个在反序列化的时候简直就是神器\n支持文本json和二进制bson序列化\nMongoDB数据库支持\n\n\n\n后面是列举MongoBson的一些使用例子，推荐直接去官网看。\n3.3 一切皆组件本篇主要介绍ECS设计，OW(守望先锋)率先使用ECS这种设计并取得巨大成功。它采用了状态帧这种网络技术：即客户端服务器端拥有一套相同逻辑，客户端进行预测行为，先进行客户端表现，而后和服务器端的预测行为做对照，不匹配的话就进行回滚。（预测这个词我这里还是有点不太理解，后面还需要去查查。）使用组件式开发的话，则只需要回滚对应组件即可。\nECS的重点在于逻辑与数据完全分离，EC是纯数据，System是逻辑，由数据驱动逻辑。而数据驱动逻辑的意思即：通过Update（tick）检测数据变化，通过事件机制来订阅数据变化。\n作者认为传统的ECS书写逻辑的方式有让组件过于稀碎化的缺点，导致组件非常多且开发人员只熟悉自己的模块，造成大量冗余。Entity和Component通常只有一层，组件一多可能不知道要使用哪些Component。合理的做法是以树状的方式管理组件，Entity可以管理Component，Component管理Entity，甚至Component还可以挂载Component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n在ET框架里，所有数据都是Component，包括Entity，Entity继承于ComponentWithId，ComponentWithId继承于Component，所以Entity本质上也是一个Component，只不过它可以挂载其它的Component。\n实际使用中可以继承Component，ComponentWithId，Entity三者之一，\n\n如果该类需要挂载组件则继承Entity。\n如果不需要挂载组件，但是需要带个逻辑ID则继承ComponentWithId。\n其他情况继承Component。\n\nET的Entity可以有数据成员，通用的数据放在Entity上作为成员，不通用的作为组件挂载在Entity上，比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在Entity身上使用会更加方便。\n\nclass Item: Entity\n&#123;\n    // 道具的配置Id\n    public int ConfigId &#123; get; set; &#125;\n    // 道具的数量\n    public int Count &#123; get; set; &#125;\n    // 道具的等级\n    public int Level &#123; get; set; &#125;\n&#125;\n\nET的树状数据结构:顶层Game.Scene，不同模块的数据都挂载在Game.Scene上，每个模块下可以挂载很多数据。比如做一个道具系统，设计一个ItemsComponent挂载在Player上即可，需要技能开发一个SkillComponent挂载在Player上。全服需要做一个活动，则开发一个活动组件挂载到Game.Scene上，这种设计会十分简洁且模块化。\n组件的细节1.组件的创建组件的创建统一由ComponentFactory创建，该工厂类提供了Create,CreateWithParent,CreateWithId三个方式。其中Create是最简单的创建方式，它做了几个处理。\n\n根据组件类型构建一个组件。\n将组件加入事件系统，并且抛出一个AwakeSystem。\n是否启用对象池。\n\nCreateWithParent在Create基础上提供了一个Parent对象，设置到Component.Parent字段上。\nCreateWithId是用来创建ComponentWithId或者其子类的，在Create的基础上可以自己设置一个Id, Component在创建的时候可以选择是否使用对象池。\n三类工厂方法都带有一个fromPool的参数，默认是true。\n2.组件的释放Component有非托管资源，所以需要继承一个IDisposable接口，用于显示释放资源。使用该接口主要做如下操作\n\n抛出Destory System。\n如果组件是对象池创建的，那么在这里会放回对象池。\n从全局事件系统(EventSystem)中删除该组件，并且将InstanceId设为0。如果组件挂载Entity身上，那么Entity调用Dispose的时候会自动调用身上所有Component的Dispose方法。\n\n3.InstanceId的作用","slug":"ET框架学习-ETBook阅览","date":"2022-06-30T04:24:40.000Z","categories_index":"通用","tags_index":"ET框架,探索发现,C#","author_index":"HalfReunion"},{"id":"0eeec1440f5c3f42f857474d88fef113","title":"UnityEngine.Object和System.Object","content":"引子\nstring s = string.Empty;\nvar go = new GameObject(\"goodBoy\");\n        \nDestroyImmediate(go);\ngo = null;\nif (!go) s += \"A\";\n\nif (go is null) s += \"B\";\n        \nif (go == null) s += \"C\";\n\nif ((System.Object)go == null) s += \"D\";\n\nDebug.Log(s);\n\n\n最后输出AC。\n首先而System.Object的&#x3D;&#x3D;null是判断是否为空指针，\n而UnityEngine.Object的”&#x3D;&#x3D;”是做过操作符重载的，当然也重载了≠。\nUnityEngine.Object的&#x3D;&#x3D;会调用以下的片段。\nprivate static bool CompareBaseObjects(Object lhs, Object rhs)\n&#123;\n\t//强转为System.object\n\t//操作符左边的值是否为null\n    bool flag = (object)lhs == null;\n\t//操作符右边的值是否为null\n    bool flag2 = (object)rhs == null;\n\n\t//都为null 返回true\n\t//此处说明，如果C#方面的引用已被置为空引用,那游戏对象肯定不存在.\n    if (flag2 &amp;&amp; flag)\n    &#123;\n        return true;\n    &#125;\n\t\t\t\t\t\t\n\t\t\t\t\t\t \n    if (flag2)\n\t&#123;\n        return !IsNativeObjectAlive(lhs);\n    &#125;\n\n    if (flag)\n    &#123;\n        return !IsNativeObjectAlive(rhs);\n    &#125;\n\t\t\t\t\t  \n\t//（通过对GUID和LocalID的计算，得到全局唯一的m_InstanceID）\n\t// 对比二者的m_InstanceID\n    return lhs.m_InstanceID == rhs.m_InstanceID;\n&#125;\n\n另一段是\nprivate static bool IsNativeObjectAlive(Object o)\n&#123;\nif (o.GetCachedPtr() != IntPtr.Zero)\n&#123;\n    return true;\n&#125;\n//判断对象是否派生自MonoBehaviour 或者 ScriptableObject\nif (o is MonoBehaviour || o is ScriptableObject)\n&#123;\n    return false;\n&#125;\n//判断InstanceID还存不存在\nreturn DoesObjectWithInstanceIDExist(o.GetInstanceID());\n\n&#125;\n\n得出结论：对于被Destory掉了的UnityEngine.Object对象（底层C++对象），上面挂载的代码已经不会继续执行，C#方面的引用变量是否置为空引用已经无关紧要。\n所以Unity重写了UnityEngine.Object的判空，只判断UnityEngine.Object是否被销毁（注意这个销毁让UnityEngine.Object不能继续执行它上面的代码），而不是C#引用是否被置为null。\n题外话：像是？和？？都是跟System.Object靠边的，慎用在UnityEngine.Object上。\n对于UnityEngine.Object被销毁后，C#层面的引用几时会置为空引用和实例几时被GC掉，这个有待考据。\n","slug":"UnityEngine-Object和System-Object","date":"2022-06-29T03:32:19.000Z","categories_index":"Unity","tags_index":"C#,基础","author_index":"HalfReunion"},{"id":"9f9e7828b8716ddb566b45d44fabc1de","title":"小技巧_u3d_C#","content":"1，使用Physics.OverlapSphereNonAlloc，不会像Physics.OverlapSphere那样创建出Collider[]数组出来，它生成的是一个int值类型，这意味着就不会分配内存空间，不会产生GC，很多检测都有NonAlloc，有些情况可以考虑使用这些OverLapXXXNonAlloc。\n2，对于两个脚本间互相调用，会遇到start与start间初始化时间存在乱序而空引用的错误，此时可以用访问器解决，\nxxx xx get&#123;\n\tif(_xx==null)&#123;\n\t\t_xx = GetComponent&lt;xxx>();\n\t&#125;\n\treturn _xx;\n&#125;\n\n3，yield return new 产生的GC问题。可以生成一个静态对象解决。\npublic static class YieldHelper\n&#123;\n\t\tpublic static WaitForEndOfFrame WaitForEndOfFrame = new WaitForEndOfFrame();\n\t\t\npublic static IEnumerator WaitForSeconds(float totalTime,bool ignoreTimeScale = false)\n&#123;\n\t\tfloat time = 0;\n\t\twhile(time &lt; totalTime)\n&#123;\n\t\ttime += (ignoreTimeScale?Time.unscaledDeltaTime:Time.deltaTime);\n\t  yield return null;\n&#125;\n&#125;\n&#125;\n\n4，enum : byte 的作用这个表示枚举元素使用 byte 存储。普通声明的话，是继承int。例 public enum Icon_Type : int继承自byte可以稍微减少一点内存占用。\n5，对比int比对比string效率更高，所以有些地方可以考虑用将字符串转化为哈希值再对比。当然可能有哈希冲突的风险。\n","slug":"小技巧_u3d_C#","date":"2022-06-28T09:02:08.000Z","categories_index":"Unity","tags_index":"C#","author_index":"HalfReunion"},{"id":"1350894a588790266d2094e5ec7bddd0","title":"UI的DrawCall计算","content":"总结提取自uwa4d的文章：https://edu.uwa4d.com/course-intro/0/126\n影响DrawCall的元素有三点：Depth值，Material，Texture。\nDepth值：\n\n需要按照Hierarchy面板的节点顺序，从上到下进行Depth分析。（使用深度优先原则）\n\n跳过不渲染的节点，比如active&#x3D;false，Canvas不渲染的Layer等（使其depth为-1）。\n\n如果处于渲染状态，但是Hierarchy面板的他下面没有其他元素跟他相交，其Depth值为0。\n\n\n不是RectTransform的Rect相交，而是渲染元素有没有重叠。\n\n\n如果有相交，找到其中最大depth值(把值记作MaxLowerDepth)的元素，判断是否能与相交的合批\n\n（即Batch，条件为Material和Textrue相同），如果能，则当前depth值&#x3D;MaxLowerDepth。\n若不能Batch，则相交的depth值&#x3D;MaxLowerDepth+1。（计算可从最底层往上算）\n\n\n计算完Depth值后，获得材质球Material的InstanceID先进行升序排序，得出以下顺序的List\n\n之后获取TextTure ID的InstanceId，并再进行一次升序排序，最终得到下面顺序的List。\n使用SpriteAltas的图集或者使用Tp打包的图集，TextTure ID就是图集的ID。\n使用单个图片没有图集，TextTrueID就是其本身的ID，说明打包图集可以让元素拥有同一纹理。\n\n决定1次DrawCall就是List中相邻相同的Depth，MaterialID和TextureID，上图的DrawCall是638&#x2F;10138&#x2F;10414&#x2F;638，4个DrawCall。\n如果出现这种情况，就优先从Hieraphy上往上搜寻。\n\n另一情况：PosZ不为0\n当父节点Pos Z 不为0，子节点Pos Z为0时，子节点满足以下条件可合批：\n\n满足图集一致，材质一致等基本条件。\n在Hierarchy相邻。\n跟Depth值以及其他节点是否相交没关系。\n\n当父节点Pos Z为 0，子节点Pos Z不为0时：\n\n父节点下所有子节点都满足合批条件，无论子节点PosZ都可以合批。\n\n父节点下所有子节点都满足基本合批条件（部分图集和材质一致），则合批受Hierarchy的节点顺序影响。\n\n\n\n根据以上规则，就可以得出一些“摆UI”的技巧：\n\n有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。\n要注意UI元素间的层叠关系，建议用“T”工具查看其矩形大小，因为有些图片透明，但是却叠在其它UI上面了，然后又无法Batch的话，就会无故多许多Drawcall；\nUI中出现最多的就是img与Text组件，当Text叠在img上面（如Button)，然后Text上又叠了一个图片时，就会至少多2个Drawcall，可以考虑将字体直接印在下面的图片上；\n有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。\n\n","slug":"UI的DrawCall计算","date":"2022-06-28T08:25:28.000Z","categories_index":"Unity","tags_index":"UI,优化","author_index":"HalfReunion"},{"id":"0b6ba2c8e01bb1370597130d76cb280b","title":"制作一个跑酷系统","content":"1，人物控制和相机控制1：控制相机与角色的偏移transform.position = new Vector3(x,x,x)+ followTarget.position;\n\n2：让相机以角色为中心点，以一个圆为周期转动。\ntransform.position = Quaternion.Euler(x轴转向, y轴转向, 0) * new Vector3(0,0,距离角色距离) \n+ followTarget.position + 中心点的偏移量;\n\ntransform.rotation = Quaternion.Euler(x轴转向, y轴转向, 0)\n\n3：移动和根据相机位置调整方位知识点 : 四元数 * 向量 &#x3D; 旋转后的向量 （注意左右乘）\n//监控按键 0渐变为1或者-1\nfloat h = Input.GetAxis(\"Horizontal\");\nfloat v = Input.GetAxis(\"Vertical\");\n\n//监控按键的量，有值说明有按键\nfloat moveAmount = Mathf.Clamp01(Mathf.Abs(h) + Mathf.Abs(v));\n\n//构建移动向量，注意椭圆映射\nvar moveInput = (new Vector3(\n            h * Mathf.Sqrt(1 - Mathf.Pow(v,2) / 2.0f), \n            0, \n            v * Mathf.Sqrt(1 - Mathf.Pow(h, 2) / 2.0f)));\n\n//获得相机的旋转量 并乘上移动向量，获得旋转后向量\nvar moveDir = cameraController.PlanarRotation * moveInput;\n\n//若有按键\nif (moveAmount > 0) \n        &#123;   //移动\n            transform.position += moveDir * moveSpeed * Time.deltaTime;\n            //保存转动方向\n\t\t\ttargetRotation = Quaternion.LookRotation(moveDir);\n         \n        &#125;\n\n//转动角色朝向\ntransform.rotation= Quaternion.RotateTowards(\ntransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);\n\t\n//设置混合树 \n//dampTime: 用 dampTime 长的时间，将 我们设置的叫做  name 的 float类型 的值由 原本的值 改变到给定的 value 值。\n//deltaTime：两次执行该方法的时间间隔。（因为这个方法会每 deltaTime 执行一次，直到 name = value）\nanimator.SetFloat(Animator.StringToHash(\"NormalAmount\"), moveAmount,0.2f,Time.deltaTime);\n\n\n4：转用CharacterController来控制角色移动CC自带有胶囊碰撞体。一般来说这类东西的组合是Rb+Collider或者单独一个CC。CC适用于第一人称或者第三人称人物角色控制，但是需要自己写一些东西比如重力。\nCharacterController \n1.Character Controller不是基于物理，没有重力，没有阻力，没有加速度，所有移动都是精确的\n\n2.Character Controller可以跨过物体，也就是上台阶，不过会一顿一顿，同是下楼梯需要自己写重力\n\n3.Character Controller 不会对 Rigidbody产生反应\n\n4.Character Controller自带地面监测，不过好像有BUG，一般还是自己写\n\n5.Character Controller的移动通过向量控制，自带碰撞监测\n\nRigidbody\n1.Rigidbody是基于物理的，所以移动会比较平滑自然，但是因为有各种力，所以很难保证精确度\n\n2.Rigidbody会对Rigidbody产生反应\n\n3.Rigidbody的移动通过力或者速度控制，不加碰撞体就不会产生碰撞\n\n\n//transform.position += moveDir * moveSpeed * Time.deltaTime;\n//改成\ncharacterController.Move(moveDir * moveSpeed * Time.deltaTime);\n\n5：使用Physics物理检测检测是否踩在地板上，并且添加重力影响。\n[SerializeField] float groundCheckRadius;\n[SerializeField] Vector3 groundCheckOffset;\n[SerializeField] LayerMask groundLayer;\n[SerializeField] bool isGround;\nGroundCheck(); \n//如果踩在地板上\nif (isGround) \n&#123;\n   ySpeed = -0.5f;\n&#125;else&#123;\n\t//添加一个向下的量，用以模拟重力掉落。\n   ySpeed += Physics.gravity.y ;\n&#125;\nvar velocity = moveDir * moveSpeed;\n\n//添加向下的量\nvelocity.y = ySpeed;\n\n//\ncharacterController.Move(velocity * Time.deltaTime);\n\nprivate void GroundCheck() &#123;\n//射线检测，创建一个球体用来检测\n    isGround = Physics.CheckSphere(transform.TransformPoint(groundCheckOffset) ,\n    groundCheckRadius, \n    groundLayer.value);\n&#125;\n\n\n2.跑酷系统1.墙面扫描设定一个墙面扫描的脚本，用处是扫描人物面前的障碍物。\n对于不同高度的障碍物，需要使用射线扫描面前的障碍物高度，然后根据高度选择播放的动画。\n//前向射线的偏移值\n[SerializeField] Vector3 forwardRayOffset;\n//前向射线长度\n[SerializeField] float forwardRayLength = 0.8f;\n//扫描高度值的射线最大值\n[SerializeField] float heightRayLength = 5f;\n//用于标识障碍物的层\n[SerializeField] LayerMask obstacleLayer;\n\npublic ObstacleHitData ObstacleCheck() \n&#123;\n    var hitData = new ObstacleHitData();\n    var forwardOrigin = transform.position + forwardRayOffset;\n        \n    //前向射线\n    hitData.forwardHitFound = Physics.Raycast(forwardOrigin, \n    transform.forward,\n    out hitData.forwardHit, forwardRayLength,obstacleLayer);\n\n    Debug.DrawRay(forwardOrigin, transform.forward * forwardRayLength,(hitData.forwardHitFound) ?Color.red:Color.white);\n\n    if (hitData.forwardHitFound) &#123;\n        //碰撞点上面往下射,刚好碰到面前物体的边缘,算出障碍物的总高度,需要减去人物最低点才能得到实际高度。\n        var heightOrigin = hitData.forwardHit.point + Vector3.up \n        * heightRayLength;\n\n        hitData.heightHitFound = Physics.Raycast(heightOrigin,Vector3.down,\n        out hitData.heightHit,heightRayLength,obstacleLayer);\n\n        Debug.DrawRay(heightOrigin,Vector3.down * heightRayLength,(hitData.forwardHitFound) ? Color.red : Color.white);\n\n        Debug.Log(hitData.heightHit.point);\n    &#125;\n        return hitData;\n&#125;\n\npublic struct ObstacleHitData &#123;\n    //前向射线是否有碰撞\n    public bool forwardHitFound;\n    //高度射线是否有碰撞\n    public bool heightHitFound;\n    //前向射线\n    public RaycastHit forwardHit;\n    //高度射线\n    public RaycastHit heightHit;\n&#125;\n2.播放动画首先封装一个行为类ParkourAction，继承自ScriptObject，用于存储动画信息和触发动画需要的条件。\n[SerializeField] private  string animName;\n//可播放动画的最低高度\n[SerializeField] private float minHeight;\n//可播放动画的最高高度\n[SerializeField] private float maxHeight;\n\n//是否要角色转向障碍物\n[SerializeField] bool rotateToObstacle;\n\n[Header(\"使用Target Matching\")]\n[SerializeField] bool enabledTargetMatching = true;\n[SerializeField] AvatarTarget matchBodyPart;\n[SerializeField] float matchStartTime;\n[SerializeField] float matchTargetTime;\n\n//存储四元数,里面是射线碰撞到的障碍物的法线方向取反,即角色朝向障碍物面的四元数。\npublic Quaternion TargetRotation &#123; get; set; &#125;\npublic Vector3 MatchPos &#123; get; set; &#125;\n\n//检测条件是否符合播放动画的要求\npublic bool CheckIfPossible(ObstacleHitData hitData, Transform player) &#123;\n    //减去人物的高度得出障碍物的高度\n    float height = hitData.heightHit.point.y - player.position. y;\n    Debug.Log($\"面前的障碍物高度为:&#123;height&#125;\");\n    \n    if (height &lt;= minHeight || height > maxHeight) &#123;\n        return false; \n    &#125;\n\n    if (rotateToObstacle)\n    &#123;\n        \n        TargetRotation = Quaternion.LookRotation(-hitData.forwardHit.normal);\n    &#125;\n       \n    if (enabledTargetMatching) &#123;\n        MatchPos = hitData.heightHit.point;\n    &#125;\n    return true;\n&#125;\n\npublic string AnimName => animName;\npublic bool RotateToObstacle => rotateToObstacle;\n\npublic bool EnabledTargetMatching => enabledTargetMatching;\npublic AvatarTarget MatchBodyPart=> matchBodyPart;\npublic float MatchStartTime => matchStartTime;\npublic float MatchTargetTime => matchTargetTime;\n\n\n对于跨越或者攀爬这种会实际产生模型位移的动画，需要注意Animator的Apply Root Motion和动画Import Setting里Animation的Bake Into Pose，此处需要将Animator组件的Apply Root Motion勾选上。使用协程来执行跨越障碍物的动画，\nIEnumerator DoParkoutAction(ParkourAction action) &#123;\n    //是否在播放动画\n    inAction = true;\n    //角色控制器是否可控\n    playerController.SetControl(false);\n    animator.CrossFade(action.AnimName, 0.1f);\n    //animator.Play(\"StepUp\");\n    yield return null; \n\n    \n    //此函数在过渡期可用,获得下一个动画状态\n    var animState = animator.GetNextAnimatorStateInfo(0);\n    if (!animState.IsName(action.AnimName)) &#123;\n        Debug.Log(\"The parkour animation is wrong\");\n    &#125;\n         \n\n    float timer = 0f;\n    //动画播放中\n    while(timer &lt;= animState.length)\n    &#123;\n        timer += Time.deltaTime;\n\n        if (action.RotateToObstacle) &#123;\n            //转向障碍物\n            transform.rotation = Quaternion.RotateTowards(\n            transform.rotation,\n            action.TargetRotation,\n            playerController.RotationSpeed * Time.deltaTime);\n        &#125;\n\n        //目标匹配,后面再讲\n        if (action.EnabledTargetMatching) &#123;\n            MatchTarget(action);\n        &#125;\n\n        yield return null;\n    &#125;\n\n    //解除锁定\n    inAction = false;\n    playerController.SetControl(true);\n    &#125;\n\n\n3.优化动画出现的问题：\n\n动画在播放结束后，脚部会出现障碍物穿模或者高过障碍物的情况。\n\n有攀墙动作的动画，手部无法真正抓住边缘。\n\n攀爬结束后按前进会导致人物平移一段时间。\n\n攀爬过程中整个人穿模。\n\n\nTarget Matching 目标匹配Unity手册的描述：通常在游戏中可能出现以下情况：角色必须以某种方式移动，使得手或脚在某个时间落在某个地方。例如，角色可能需要跳过踏脚石或跳跃并抓住顶梁。这种情况可以用Target Maching。(似乎只能用在AnimatorController里)\n我们的动画里有跃起，然后踏上障碍体的动作。首先要在AnimationClip里找到动画标准化时间的两个点，1个是角色离地的时间点，1个是踏上障碍体,结束落地的时间点。\nvoid MatchTarget(ParkourAction action) &#123;\n    //是否要使用了目标匹配\n    if (animator.isMatchingTarget) &#123;\n        return;\n    &#125;\n\n    //参数解释：1.需要匹配的位置(一般为障碍物的高度值y,这里为高度射线的碰撞点位置取y值)\n    //2.角色转向的四元数。 3.系统枚举值:要匹配的肢体,人物四肢的其中1个。 4.~。 5.开始匹配的时间点。 6.结束匹配的时间点\n    animator.MatchTarget(action.MatchPos,transform.rotation,\n        action.MatchBodyPart,\n        new MatchTargetWeightMask(new Vector3(0,1,1),0),\n        action.MatchStartTime,\n        action.MatchTargetTime);\n    &#125;\n\n第1点，这时候可以调整,调为feet。\n使用 Feet__ 时，对于所有帧，Root Transform Position Y 将与位置最低的脚 Y 匹配。因此，混合点始终保持在脚周围，从而防止在混合或过渡时发生浮动问题。\n脚超模的现象可以按第2点调。\n第2点，需要调整MatchTarget第4个参数，Unity手册里写的是：包含匹配位置和旋转的权重的结构，使用此结构可为 Animator.MatchTarget 指定位置和旋转权重遮罩。\n有一个Vector3类型的参数positionXYZWeight:位置 XYZ 权重,值在0~1之间。\n一个float类型的参数rotationWeight:\t旋转权重\n这里把positionXYZWeight的z值设为最高值1,这样匹配的权重会偏向障碍物平面的最边缘，可以把这个权重值封装在ScriptObject行为类里。同理把y值设为1,说明在匹配y值方面,会把权重偏向最接近障碍物平面上,这样就不容易出现脚穿模在地下的情况。\n第3点，这里有一点上述的代码里没讲，因为攀爬动作没有从蹲下到站立的动画，所以攀爬结束后混合了一段蹲到站立的动画。而这里是由于使用了Time.deltaTime只等待了一段AnimationClip的播放，没有等待蹲下到站立的部分。这段的解决比较宽泛，可以用yield return 再等待一段时间。\n第4点，这个是因为Match Target的匹配时间点没设好，只能慢慢调了。\n","slug":"制作一个跑酷系统","date":"2022-06-26T11:44:10.000Z","categories_index":"Unity","tags_index":"C#,制作实例,动画系统","author_index":"HalfReunion"},{"id":"df72ebc7475da7a2a818b4e6f4f94099","title":"Time函数和Update和FixedUpdate","content":"Time.timeScale 不会影响Update和LateUpdate的执行速度。\nFixedUpdate是根据Time.time来执行的，所以Time.timeScale会影响到FixedUpdate的执行。\nFixedTimeStep中的设置是指Time.time的时间变化，如果设置为0.02s，则意味着Time.timeScale&#x3D;1的情况下，Time.time的值每过0.02秒就调用一次FixedUpdate。\nTime.deltaTime：表示当前时刻到上一帧所经过的秒数，具体值和当前游戏的帧数有关。Time.deltaTime的值在update上 &#x3D; 1&#x2F;帧率 * Time.timeScale。同时也是Time.time的增量值。 \n所以在Update中进行物体移动的话，需要Time.deltaTime * speed * Vector3方向向量,相当于每秒往Vector3方向移动speed距离。\n\nFixedUpdate，固定的一个时间频率去调整； \nUpdate，根据系统性能的FPS速率有影响关系；\n关于上两条的一些证明\npublic void FixedUpdate()\n    &#123;\n        i++;\n        Debug.Log(\"这在是第\" + i + \"帧\");\n        time += Time.deltaTime;\n        Debug.Log(\"时间：\" + time);\n    &#125;\n\n上面的time值始终是以0.02的量去增长。\nvoid FixedUpdate()\n&#123;\n\tDebug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\nvoid Update()\n&#123;\n\tDebug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\n经此测试可发现，在帧率较低的情况下，FixedUpdate并不是间隔0.02秒才调用一次，有可能在Update前调用多次，间隔的时间也不一定，当我们设置FixedUpdate的步长为0.02秒（50FPS）时，设置刷新的频率为30FPS，FixedUpdate每秒的调用次数势必要多于Update。\n[SerializeField]\n float time = 0f;\n [SerializeField]\n float Fixedtime = 0f;\nvoid FixedUpdate()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        Debug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n        Debug.Log(\"FixedUpdate deltaTime: \" + Time.deltaTime);\n        Fixedtime += Time.deltaTime;\n\n    &#125;\n\n    void Update()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        time += Time.deltaTime;\n        \n        Debug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n    &#125;\n\n验证两者对于真实时间的联系，设置游戏帧率为10帧，在经过1秒后，二者的增量几乎一致。\n\n已知，Update的调用次数为1秒钟调用帧数次，FixedUpdate设置的步长为0.02。则1&#x2F;0.02 &#x3D; 50FPS。\n\n所以说FixedUpdate固定时间频率是指，会在1秒内调用 （1&#x2F;设置的步长） 次FixedUpdate，而不一定是经过真实时间里 设置的Fixed Step  秒就调用1次，两次FixedUpdate调用的间隔其实是Time.time经过 设置的步长。\n而Update则是根据游戏内的帧率时刻浮动来决定执行次数。\n所以，FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。\n因为它是用来处理物理模拟的，更重要的是它并非根据真实时间的间隔执行，而只是有一个固定的量。\n关于为何要推荐在FixedUpdate处理物理逻辑：在物理模拟中，保证一个固定的增量时间是十分重要的。这是因为在游戏引擎进行物理模拟时要使用数值积分，而作为最简单的数值积分方法——欧拉法在游戏引擎中大量使用。而在游戏引擎的物理模拟中，一个不稳定的增量时间可能导致很多和预期相悖的结果。\n固定的增量时间作为一个常量参数传递给物理模拟模块，这样我们就能够保证物理模拟的增量时间固定，同时还能将物理模拟的更新频率和游戏引擎的更新频率进行解耦——物理的模拟不受引擎的更新频率影响，无论游戏的更新频率是多少，传递给物理模拟的增量时间都是一个常量。\nOnTrigger，OnCollision系列和FixedUpdate都依赖物理步，也就是Fixed Step来触发。\n而如果将输入检测或者需要每帧检测的逻辑放入物理步中判断就会出错。\n\nTime.timeScale 会影响Time.Time，比如Time.timeScale ＝ 2的话，那么Time.time的增长速度也会变成2倍速度。\n如果你想取到游戏的实际时间，那么使用Time.timeSinceLevelLoad就可以，前提是必须在**Awake()方法以后再取，如果在Awake()**方法里面取Time.realtimeSinceStartup会取出一个错误的值，在Start方法里面取的话就正常了。\n总之一句话Time.timeScale影响的是Unity的游戏时间缩放比例。\nUnity里面所有跟时间有关系的东西都是根据timeScale来演算的。\n仔细想想现在的手游就是个 动画 和 粒子技能特效 还有UI位移特效，所以改他们的速度直接用Time.timeScale就可以完成。还有一个重要的东西就是人物移动 或者 技能移动的速度了，\n 根据时间的公式，时间 ＝ 路程\\速度 ，比如角色从起点跑到中间的一个预期时间， 或者一个技能的火球从攻击到打中目标的预期时间。 凡是处理时间的东东全用Time.time 这样就可以完美让Time.timeScale控制你的游戏了。\n\n有关于LateUpdate的操作，事关摄像机跟随游戏对象时会发生抖动的阐述。\n画面抖动的原因是因为摄像机位置更新与目标(抖动对象)位置更新不同步造成的.\n结论：1）Time.time的每帧的增量即为Time.deltaTime\n2）Time.deltaTime和Time.time都受Time.timeScale影响，且是正比的关系\n3）Time.deltaTime的最大调用时间间隔为Time面板的 Maximum Allowed Timestep 值\n4）Time.realtimeSinceStartup不受Time.timeScale影响，它为真实的游戏时间\n5）Update的调用不受Time.timeScale影响，它的调用间隔和真实的上一帧调用时间有关\n6）LateUpdate的调用同Update，不受Time.timeScale影响（截图时忘了开打印，实际同Update）\n7）FixedUpdate的调用受Time.timeScale影响，且成正比，当Time.timeScale &#x3D; 0时，FixedUpdate不被调用\n8）FixedUpdate的调用时间间隔为Time面板的 Fixed Timestep 值，受Time.time影响。\n\nFixedUpdate在每帧的调用不固定，有可能执行多次，有可能不执行。\n\n总结：1）想让游戏对象受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.time &#x2F; Time.deltaTime 做关联计算并放在Update中更新，或者将它放在FixedUpdate中做更新（使用Time.fixeddeltaTime，或按帧计算）\n2）想让游戏对象不受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.realtimeSinceStartup 做关联计算并放在Update中更新\n3）Unity中默认Animation、Animator和粒子特效都是受Time.timeScale（子弹时间）影响的\n4）想让Animator不受Time.timeScale（子弹时间）影响时，可以将它的更新模式改为：animator.updateMode &#x3D; AnimatorUpdateMode.UnscaledTime;\n5）想让Animation或粒子特效不受Time.timeScale（子弹时间）影响时，要用Time.realtimeSinceStartup做采样计算，并对它们做更新\n\n额外部分内容的链接https://blog.csdn.net/cube454517408/article/details/107496353\n关于Time相关的例子：\n1，子弹时间（缓慢的粒子特效 或者 只有自己不受影响\n2，定时回调系统\n3，暂停游戏\n设置 Time.timeScale ＝ 0；即可让游戏暂停。 其实我们暂停的主要是 人物动画，还有技能特效，比如一个火球打了一半。\nUI方面往往我们不希望暂停，比如暂停界面 有一些UI位移动画或者帧动画， 或者最起码要有个“取消暂停的按钮” 吧。 总不能游戏暂停了我点击按钮，按钮的点击动画或者特效也暂停了吧。\n所有的动画都是基于时间来的，因为Time.timeScale ＝ 0了，所以Time.time也就不会在变化了。换句话来说如果游戏暂停以后想在暂停界面上继续播放一些不受Time.timeScale 影响的动画，那么我们就需要用到Time.realtimeSinceStartup。\nAnimationState animState = animation[clipName]; // 当前动画状态\nanimation.Play(clipName);//播放动画\ncurTime = Time.realtimeSinceStartup; // 当前真实时间\ndeltaTime = curTime - lastFrameTime; // 此帧与上一帧的时间间隔\nlastFrameTime = curTime; // 记录此帧时间，下一帧用\nprogressTime += deltaTime; // 动画已播放时间\nanimState.normalizedTime = progressTime / currState.length; // 动画规范化时间[0-1]\nanimation.Sample(); // 在当前状态对动画进行采样，当你想显式设置动画状态并且对它取样的时候使用\n\n\n附录： 只读:\nTime.time：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。Time.deltaTime：表示从上一帧到当前帧的时间，以秒为单位。Time.unscaleddeltaTime：不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。Time.timeSinceLevelLoad：表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。Time.unscaledTime：不考虑timescale时候与time相同，若timescale被设置，则无效。Time.fixeddeltaTime：表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。Time.realtimeSinceStartup： 表示自游戏开始后的总时间，即使暂停也会不断的增加。Time.frameCount：总帧数\n 可读可写:\nTime.fixedTime：表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixeddeltaTime）直到达到time属性。Time.SmoothdeltaTime：表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。Time.timeScale：时间缩放，默认值为1，若设置&lt;1，表示时间减慢，若设置&gt;1,表示时间加快，可以用来加速和减速游戏，非常有用。Time.captureFramerate：表示设置每秒的帧率，然后不考虑真实时间。 \n\n帧数显示器和设置游戏整体帧率的代码：\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FPS : MonoBehaviour\n&#123;\n    private float m_LastUpdateShowTime = 0f;  //上一次更新帧率的时间;  \n\n    private float m_UpdateShowdeltaTime = 0.01f;//更新帧率的时间间隔;  \n\n    private int m_FrameUpdate = 0;//帧数;  \n\n    private float m_FPS = 0;\n\n    void Awake()\n    &#123;\n\t\t\t\t//设置帧率\n        Application.targetFrameRate = 30;\n    &#125;\n\n    // Use this for initialization  \n    void Start()\n    &#123;\n        m_LastUpdateShowTime = Time.realtimeSinceStartup;\n    &#125;\n\n    // Update is called once per frame  \n    void Update()\n    &#123;\n        m_FrameUpdate++;\n        if (Time.realtimeSinceStartup - m_LastUpdateShowTime >= m_UpdateShowdeltaTime)\n        &#123;\n            m_FPS = m_FrameUpdate / (Time.realtimeSinceStartup - m_LastUpdateShowTime);\n            m_FrameUpdate = 0;\n            m_LastUpdateShowTime = Time.realtimeSinceStartup;\n        &#125;\n    &#125;\n\n    void OnGUI()\n    &#123;\n        GUIStyle labelFont = new GUIStyle();\n        labelFont.fontSize = 20;\n        GUI.Label(new Rect(Screen.width / 2, 0, 100, 100), \"FPS: \" + m_FPS, labelFont);\n    &#125;\n&#125;\n\n关于deltaTime比较粗浅的解释：https://www.cnblogs.com/jiangxiaoming/p/12983807.html\n","slug":"Time函数和Update和FixedUpdate","date":"2022-06-26T08:17:29.000Z","categories_index":"Unity","tags_index":"探索发现,C#,Api","author_index":"HalfReunion"}]