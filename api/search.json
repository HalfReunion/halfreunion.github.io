[{"id":"0b6ba2c8e01bb1370597130d76cb280b","title":"制作一个跑酷系统","content":"制作跑酷系统1，人物控制和相机控制\n1：控制相机与角色的偏移\ntransform.position = new Vector3(x,x,x)+ followTarget.position;\n\n2：让相机以角色为中心点，以一个圆为周期转动。\n\ntransform.position = Quaternion.Euler(x, x, x) * new Vector3(x,x,x) + followTarget.position;\ntransform.rotation = Quaternion.Euler(x, x, x)\n\n3：移动和根据相机位置调整方位\n知识点 : 四元数 * 向量 &#x3D; 旋转后的向量\n//监控按键 0渐变为1或者-1\nfloat h = Input.GetAxis(\"Horizontal\");\nfloat v = Input.GetAxis(\"Vertical\");\n\n//监控按键的量，有值说明有按键\nfloat moveAmount = Mathf.Clamp01(Mathf.Abs(h) + Mathf.Abs(v));\n\n//构建移动向量，注意椭圆映射\nvar moveInput = (new Vector3(\n            h * Mathf.Sqrt(1 - Mathf.Pow(v,2) / 2.0f), \n            0, \n            v * Mathf.Sqrt(1 - Mathf.Pow(h, 2) / 2.0f))).normalized;\n\n//获得相机的旋转量 并乘上移动向量，获得旋转后向量\nvar moveDir = cameraController.PlanarRotation * moveInput;\n\n//若有按键\nif (moveAmount > 0) \n        &#123;   //移动\n            transform.position += moveDir * moveSpeed * Time.deltaTime;\n            //保存转动方向\n\t\t\t\t\t\ttargetRotation = Quaternion.LookRotation(moveDir);\n         \n        &#125;\n//转动角色朝向\ntransform.rotation= Quaternion.RotateTowards(\ntransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);\n\t\n//设置混合树 \n//dampTime: 用 dampTime 长的时间，将 我们设置的叫做  name 的 float类型 的值由 原本的值 改变到给定的 　value 值。\n//deltaTime：两次执行该方法的时间间隔。（因为这个方法会每 deltaTime 执行一次，直到 name = value）\nanimator.SetFloat(Animator.StringToHash(\"NormalAmount\"), moveAmount,0.2f,Time.deltaTime);\n\n\n 4：转用CharacterController来控制角色移动，CC自带有胶囊碰撞体。一般来说这类东西的组合是Rb+Collider或者单独一个CC。CC适用于第一人称或者第三人称人物角色控制，但是需要自己写一些东西比如重力。\n\n\nCharacterController和Rb\n  1.Character Controller不是基于物理，没有重力，没有阻力，没有加速度，所有移动都是精确的\n  2.Character Controller可以跨过物体，也就是上台阶，不过会一顿一顿，同是下楼梯需要自己写重力\n  3.Character Controller 不会对 Rigidbody产生反应\n  4.Character Controller自带地面监测，不过好像有BUG，一般还是自己写\n  5Character Controller的移动通过向量控制，自带碰撞监测\n  接着是Rigidbody\n  1.Rigidbody是基于物理的，所以移动会比较平滑自然，但是因为有各种力，所以很难保证精确度\n  2.Rigidbody会对Rigidbody产生反应\n  3.Rigidbody的移动通过力或者速度控制，不加碰撞体就不会产生碰撞\n\n\n\n//transform.position += moveDir * moveSpeed * Time.deltaTime;\n//改成\ncharacterController.Move(moveDir * moveSpeed * Time.deltaTime);\n\n5：使用Physics物理检测，来检测是否踩在地板上，并且添加重力影响。\n[SerializeField] float groundCheckRadius;\n[SerializeField] Vector3 groundCheckOffset;\n[SerializeField] LayerMask groundLayer;\n[SerializeField] bool isGround;\nGroundCheck(); \n//如果踩在地板上\nif (isGround) \n&#123;\n   ySpeed = -0.5f;\n&#125;else&#123;\n\t//添加一个向下的量，用以模拟重力掉落。\n   ySpeed += Physics.gravity.y ;\n&#125;\nvar velocity = moveDir * moveSpeed;\n\n//添加向下的量\nvelocity.y = ySpeed;\n\n//\ncharacterController.Move(velocity * Time.deltaTime);\n\nprivate void GroundCheck() &#123;\n//射线检测，创建一个球体用来检测\nisGround = Physics.CheckSphere(transform.TransformPoint(groundCheckOffset) ,\ngroundCheckRadius, \ngroundLayer.value);\n&#125;\n\n\n2，墙面扫描\n对于不同高度的障碍体，需要使用射线扫描面前的\n3，Target Matching 目标匹配\n未完待续\n","slug":"制作一个跑酷系统","date":"2022-06-26T11:44:10.000Z","categories_index":"Unity","tags_index":"制作实例,动画系统","author_index":"HalfReunion"},{"id":"c7761fab9ffcd468eef26fa6ba175baa","title":"Time函数和Update","content":"Time函数和UpdateTime.timeScale 不会影响Update和LateUpdate的执行速度。\nFixedUpdate是根据Time.time来执行的，所以Time.timeScale会影响到FixedUpdate的执行。\nFixedTimeStep中的设置是指Time.time的时间变化，如果设置为0.02s，则意味着Time.timeScale&#x3D;1的情况下，Time.time的值每过0.02秒就调用一次FixedUpdate。\nTime.deltaTime：表示当前时刻到上一帧所经过的秒数，具体值和当前游戏的帧数有关。Time.deltaTime的值在update上 &#x3D; 1&#x2F;帧率 * Time.timeScale。同时也是Time.time的增量值。 \n所以在Update中进行物体移动的话，需要Time.deltaTime * speed * Vector3方向向量,相当于每秒往Vector3方向移动speed距离。\n\nFixedUpdate，固定的一个时间频率去调整； \nUpdate，根据系统性能的FPS速率有影响关系；\n关于上两条的一些证明\npublic void FixedUpdate()\n    &#123;\n        i++;\n        Debug.Log(\"这在是第\" + i + \"帧\");\n        time += Time.deltaTime;\n        Debug.Log(\"时间：\" + time);\n    &#125;\n\n上面的time值始终是以0.02的量去增长。\nvoid FixedUpdate()\n&#123;\n\tDebug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\nvoid Update()\n&#123;\n\tDebug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\n经此测试可发现，在帧率较低的情况下，FixedUpdate并不是间隔0.02秒才调用一次，有可能在Update前调用多次，间隔的时间也不一定，当我们设置FixedUpdate的步长为0.02秒（50FPS）时，设置刷新的频率为30FPS，FixedUpdate每秒的调用次数势必要多于Update。\n[SerializeField]\n float time = 0f;\n [SerializeField]\n float Fixedtime = 0f;\nvoid FixedUpdate()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        Debug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n        Debug.Log(\"FixedUpdate deltaTime: \" + Time.deltaTime);\n        Fixedtime += Time.deltaTime;\n\n    &#125;\n\n    void Update()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        time += Time.deltaTime;\n        \n        Debug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n    &#125;\n\n验证两者对于真实时间的联系，设置游戏帧率为10帧，在经过1秒后，二者的增量几乎一致。\n\n已知，Update的调用次数为1秒钟调用帧数次，FixedUpdate设置的步长为0.02。则1&#x2F;0.02 &#x3D; 50FPS。\n\n所以说FixedUpdate固定时间频率是指，会在1秒内调用 （1&#x2F;设置的步长） 次FixedUpdate，而不一定是经过真实时间里 设置的Fixed Step  秒就调用1次，两次FixedUpdate调用的间隔其实是Time.time经过 设置的步长。\n而Update则是根据游戏内的帧率时刻浮动来决定执行次数。\n所以，FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。\n因为它是用来处理物理模拟的，更重要的是它并非根据真实时间的间隔执行，而只是有一个固定的量。\n关于为何要推荐在FixedUpdate处理物理逻辑：在物理模拟中，保证一个固定的增量时间是十分重要的。这是因为在游戏引擎进行物理模拟时要使用数值积分，而作为最简单的数值积分方法——欧拉法在游戏引擎中大量使用。而在游戏引擎的物理模拟中，一个不稳定的增量时间可能导致很多和预期相悖的结果。\n固定的增量时间作为一个常量参数传递给物理模拟模块，这样我们就能够保证物理模拟的增量时间固定，同时还能将物理模拟的更新频率和游戏引擎的更新频率进行解耦——物理的模拟不受引擎的更新频率影响，无论游戏的更新频率是多少，传递给物理模拟的增量时间都是一个常量。\nOnTrigger，OnCollision系列和FixedUpdate都依赖物理步，也就是Fixed Step来触发。\n而如果将输入检测或者需要每帧检测的逻辑放入物理步中判断就会出错。\n\nTime.timeScale 会影响Time.Time，比如Time.timeScale ＝ 2的话，那么Time.time的增长速度也会变成2倍速度。\n如果你想取到游戏的实际时间，那么使用Time.timeSinceLevelLoad就可以，前提是必须在**Awake()方法以后再取，如果在Awake()**方法里面取Time.realtimeSinceStartup会取出一个错误的值，在Start方法里面取的话就正常了。\n总之一句话Time.timeScale影响的是Unity的游戏时间缩放比例。\nUnity里面所有跟时间有关系的东西都是根据timeScale来演算的。\n仔细想想现在的手游就是个 动画 和 粒子技能特效 还有UI位移特效，所以改他们的速度直接用Time.timeScale就可以完成。还有一个重要的东西就是人物移动 或者 技能移动的速度了，\n 根据时间的公式，时间 ＝ 路程\\速度 ，比如角色从起点跑到中间的一个预期时间， 或者一个技能的火球从攻击到打中目标的预期时间。 凡是处理时间的东东全用Time.time 这样就可以完美让Time.timeScale控制你的游戏了。\n\n有关于LateUpdate的操作，事关摄像机跟随游戏对象时会发生抖动的阐述。\n画面抖动的原因是因为摄像机位置更新与目标(抖动对象)位置更新不同步造成的.\n结论：1）Time.time的每帧的增量即为Time.deltaTime\n2）Time.deltaTime和Time.time都受Time.timeScale影响，且是正比的关系\n3）Time.deltaTime的最大调用时间间隔为Time面板的 Maximum Allowed Timestep 值\n4）Time.realtimeSinceStartup不受Time.timeScale影响，它为真实的游戏时间\n5）Update的调用不受Time.timeScale影响，它的调用间隔和真实的上一帧调用时间有关\n6）LateUpdate的调用同Update，不受Time.timeScale影响（截图时忘了开打印，实际同Update）\n7）FixedUpdate的调用受Time.timeScale影响，且成正比，当Time.timeScale &#x3D; 0时，FixedUpdate不被调用\n8）FixedUpdate的调用时间间隔为Time面板的 Fixed Timestep 值，受Time.time影响。\n\nFixedUpdate在每帧的调用不固定，有可能执行多次，有可能不执行。\n\n总结：1）想让游戏对象受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.time &#x2F; Time.deltaTime 做关联计算并放在Update中更新，或者将它放在FixedUpdate中做更新（使用Time.fixeddeltaTime，或按帧计算）\n2）想让游戏对象不受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.realtimeSinceStartup 做关联计算并放在Update中更新\n3）Unity中默认Animation、Animator和粒子特效都是受Time.timeScale（子弹时间）影响的\n4）想让Animator不受Time.timeScale（子弹时间）影响时，可以将它的更新模式改为：animator.updateMode &#x3D; AnimatorUpdateMode.UnscaledTime;\n5）想让Animation或粒子特效不受Time.timeScale（子弹时间）影响时，要用Time.realtimeSinceStartup做采样计算，并对它们做更新\n\n额外部分内容的链接https://blog.csdn.net/cube454517408/article/details/107496353\n关于Time相关的例子：\n1，子弹时间（缓慢的粒子特效 或者 只有自己不受影响\n2，定时回调系统\n3，暂停游戏\n设置 Time.timeScale ＝ 0；即可让游戏暂停。 其实我们暂停的主要是 人物动画，还有技能特效，比如一个火球打了一半。\nUI方面往往我们不希望暂停，比如暂停界面 有一些UI位移动画或者帧动画， 或者最起码要有个“取消暂停的按钮” 吧。 总不能游戏暂停了我点击按钮，按钮的点击动画或者特效也暂停了吧。\n所有的动画都是基于时间来的，因为Time.timeScale ＝ 0了，所以Time.time也就不会在变化了。换句话来说如果游戏暂停以后想在暂停界面上继续播放一些不受Time.timeScale 影响的动画，那么我们就需要用到Time.realtimeSinceStartup。\nAnimationState animState = animation[clipName]; // 当前动画状态\nanimation.Play(clipName);//播放动画\ncurTime = Time.realtimeSinceStartup; // 当前真实时间\ndeltaTime = curTime - lastFrameTime; // 此帧与上一帧的时间间隔\nlastFrameTime = curTime; // 记录此帧时间，下一帧用\nprogressTime += deltaTime; // 动画已播放时间\nanimState.normalizedTime = progressTime / currState.length; // 动画规范化时间[0-1]\nanimation.Sample(); // 在当前状态对动画进行采样，当你想显式设置动画状态并且对它取样的时候使用\n\n\n附录： 只读:\nTime.time：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。Time.deltaTime：表示从上一帧到当前帧的时间，以秒为单位。Time.unscaleddeltaTime：不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。Time.timeSinceLevelLoad：表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。Time.unscaledTime：不考虑timescale时候与time相同，若timescale被设置，则无效。Time.fixeddeltaTime：表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。Time.realtimeSinceStartup： 表示自游戏开始后的总时间，即使暂停也会不断的增加。Time.frameCount：总帧数\n 可读可写:\nTime.fixedTime：表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixeddeltaTime）直到达到time属性。Time.SmoothdeltaTime：表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。Time.timeScale：时间缩放，默认值为1，若设置&lt;1，表示时间减慢，若设置&gt;1,表示时间加快，可以用来加速和减速游戏，非常有用。Time.captureFramerate：表示设置每秒的帧率，然后不考虑真实时间。 \n\n帧数显示器和设置游戏整体帧率的代码：\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FPS : MonoBehaviour\n&#123;\n    private float m_LastUpdateShowTime = 0f;  //上一次更新帧率的时间;  \n\n    private float m_UpdateShowdeltaTime = 0.01f;//更新帧率的时间间隔;  \n\n    private int m_FrameUpdate = 0;//帧数;  \n\n    private float m_FPS = 0;\n\n    void Awake()\n    &#123;\n\t\t\t\t//设置帧率\n        Application.targetFrameRate = 30;\n    &#125;\n\n    // Use this for initialization  \n    void Start()\n    &#123;\n        m_LastUpdateShowTime = Time.realtimeSinceStartup;\n    &#125;\n\n    // Update is called once per frame  \n    void Update()\n    &#123;\n        m_FrameUpdate++;\n        if (Time.realtimeSinceStartup - m_LastUpdateShowTime >= m_UpdateShowdeltaTime)\n        &#123;\n            m_FPS = m_FrameUpdate / (Time.realtimeSinceStartup - m_LastUpdateShowTime);\n            m_FrameUpdate = 0;\n            m_LastUpdateShowTime = Time.realtimeSinceStartup;\n        &#125;\n    &#125;\n\n    void OnGUI()\n    &#123;\n        GUIStyle labelFont = new GUIStyle();\n        labelFont.fontSize = 20;\n        GUI.Label(new Rect(Screen.width / 2, 0, 100, 100), \"FPS: \" + m_FPS, labelFont);\n    &#125;\n&#125;\n\n关于deltaTime比较粗浅的解释：https://www.cnblogs.com/jiangxiaoming/p/12983807.html\n","slug":"Time和Update","date":"2022-06-26T08:17:29.000Z","categories_index":"Unity","tags_index":"Api","author_index":"HalfReunion"}]