[{"id":"c0e269d7e765c6c0b1340afdef40bcca","title":"对UGUI系统的理解","content":"集合看过的资料，也有混合一些理解，权当个记录的地方。大部分以luzexi大佬的笔记做导引和总结\n前言首先UGUI建立在Mesh网格之上，UI元素的实例化都是通过构建网格实现。所以当想显示一个图片，实现按钮等都会构建Mesh，然后Mesh绑定材质球，在材质球里放图片。无论是UI系统还是场景人物模型，都是遵循渲染原理和CPU工作原理，即GPU收集需要渲染的信息交于GPU进行渲染。\nUnity的动态合批原理是将相同的材质球(Material,参数也要一样:Shader和Textrue)进行网格的合并。\n所以这类UI元素的合批遵循就是下面的规则，将相同图片，相同Shader的材质球指向一个材质球，并把网格根据一些合并规则合并起来，这样就生成了几个合并后的网格+几个相同图片相同Shader的材质球，而每次动态合批都有一定代价，比如合批后会new出一个合批后的新材质球。所谓图集概念由此而生，将多张图片放在同一张图片上，使得图片和材质球不需要重复绘制，只要改变Mesh的UV坐标来进行纹理映射即可。\nUGUI会尽量使用动态合批来减少DC对CPU的消耗。\n具体合并规则可以看https://halfreunion.github.io/post/UI%E7%9A%84DrawCall%E8%AE%A1%E7%AE%97。\nCanvas就是渲染UI元素的组件，Canvas执行一次合批操作，会将其子节点的UI元素（不包括Canvas）进行合批，并将信息递交给GPU后生成DC。而当UI元素发生变化时，也会进行一次上面的操作，因为UI元素发生变化而重新去计算Graphic组件（Graphic是UGUI的核心组成部分，是一个抽象类，为 Canvas 系统提供可绘制几何图形的所有 Unity UI C# 类的基类。）的布局和网格情况的过程，被称为Rebuild。\n避免过多Rebuild也是优化的关键。\n\n组件1. Canvas 组件Canvas就是渲染UI元素的组件，比较重要的是参数是RenderMode,\n\nOverlay模式，不以Camera为基准\nCamera模式，以Camera为基准\nWorldSpace，以3D世界为标准\n\nOverlay通常处于屏幕的最前端，覆盖其他两个模式的UI元素，没有3D效果，多个该模式的Canvas同时存在的情况下，Sort Order参数越大越靠前渲染。\nCamera模式基于Camera的平面透视，渲染布局依赖绑定的Camera，该模式可以让更多非UI元素加入。是实际上UI系统里最常用的模式。UI元素的z轴若不为0，会单独拿出来渲染而不会参与合批。\nWorldSpace，基于Camera的视椎体透视，它将UI元素当做3D物体一样处理，当UI物体出现在Camera视野中时，相当于渲染了一个普通3D物体，除了普通渲染Canvas外还会对常经理的UI进行合批处理。\n三种模式混合的情况\nCamera模式和WorldSpace模式的RenderCamera都是同一相机：\nSortingLayer和Order in Layer相同的情况下\nOverlay→Camera→WorldSpace\nSortingLayer和Order in Layer不同的情况下：\nOverlay→SortingLayer→Order in Layer \nCamera模式的Canvas，会根据上面的顺序，覆盖值比它小的WorldSpace，如果它的值比WorldSpace还小，则会置于WorldSpace的底下作为背景。\n例子：\n下面带有“启动”界面是WorldSpace，背景图是的RenderMode是Camera，而左边包括好友的界面是Overlay。\n其中背景图和WorldSpace的UI所用的渲染相机都是同一个，其中背景图Canvas和WorldSpace的Canvas的SortingLayer都是Default，但是Order in Layer的值是背景图&lt;WorldSpace。\n\nCamera和WorldSpace的RenderCamera都是不同相机的情况下：\n渲染相机不同的情况下，Overlay→根据Camera的Depth值，越大越前面。\nRenderMode&#x3D;Overlay模式下， 多个Canvas并列：以Sort Order排列，值越大渲染在越前面。\nRenderMode&#x3D;Camera模式下，渲染相机都不同，多个Canvas并列情况下，以Camera的Depth值排序，越大渲染在越前面。\nRenderMode&#x3D;Camera模式下，渲染相机都是同个相机，多个Canvas并列情况下：先以SortingLayer排序，再以Order in Layer排序，越大渲染在越前面。\nRenderMode&#x3D;WorldSpace模式下，渲染相机都不同，多个Canvas并列的情况下，Camera的Depth无影响，先以SortingLayer排序，再以Order in Layer排序，越大渲染在越前面。\nRenderMode&#x3D;WorldSpace模式下，渲染相机都相同，多个Canvas并列情况下，先以SortingLayer排序，再以Order in Layer排序，越大渲染在越前面。\n\n2. Canvas-Scaler组件用来指定画布元素的比例大小，有几个重要参数可选。\n1.Constant Pixel Size：当修改屏幕宽高时，该模式下的UI将不会做大小变化。可以通过调整Scale Factor来调整UI的大小。无论屏幕大小如何，UI 元素都保持相同的像素大小。\n\n相关参数\n\n\n比较重要的参数\nScale Factor\n  调整该值可等比缩放大小。\n\nReference Pixels Per Unit\n  Texture Type为Sprite(2D and UI)的图片中,有Pixels Per Unit参数，与这个值相对应，对照两个值等比缩放大小。\n  Reference Pixels Per Unit &#x3D; 100\n  Pixels Per Unit &#x3D; 10\n  Set Native Size ，image 将等比增加十倍大小。\n  缩放后的大小 &#x3D; 原本的Width和Height*(Reference Pixels Per Unit&#x2F;Pixels Per Unit)\n\n\n\n\n\n2.Scale With Screen Size：根据一个参考值来和屏幕分辨率来对UI元素进行缩放的模式。 \n\n 比较重要的参数 \n\n\nScreen Match Mode\nMatchWidth Or Height：当实际设备的分辨率和参考分辨率(Reference Resolution)比例相同时，会等比进行缩放。\n若不同时，则会根据MatchWidth Or Height的值对宽高进行一定的权重缩放，0会让实机分辨率的宽 扩充至 参考分辨率的宽度，然后\n将 实机分辨率的高 &#x3D; 原实际分辨率的高&#x2F;（实际分辨率的宽度&#x2F;参考分辨率的宽度）\n为1则反过来，即让分辨率的高扩充至参考分辨率的高度，然后\n将 实际分辨率的宽 &#x3D; 原实际分辨率的高&#x2F;（实际分辨率的高度&#x2F;参考分辨率的高度）\n参考分辨率为 600x600，设备实际分辨率为 180x180时，Canvas 的 ScaleXY 正好等于 180&#x2F;600 为 0.3，此时是等比缩放。 此时，matchWidthOrHeight 值的变化不会影响结果。\n设备实际分辨率宽高比和参考分辨率宽高比不同时，matchWidthOrHeight 表示宽和高对于最终 Canvas 的 ScaleXY 以及 width/height 的影响程度。\n当 matchWidthOrHeight 为 0时，保持 Canvas.width 为 Reference Resolution.x 不变，缩放值Canvas.scaleXY &#x3D; Screen.width &#x2F; Canvas.width, \nCanvas.height &#x3D; Screen.height &#x2F; Canvas.scaleXY;\n当 matchWidthOrHeight 为 1 时，保持 Canvas.height 为 Reference Resolution.y 不变，缩放值Canvas.scaleXY &#x3D; Screen.height &#x2F; Canvas.height,Canvas.width &#x3D; Screen.width &#x2F; Canvas.scaleXY;\n当matchWidthOrHeight处于最左边时，实际设备的屏幕高度对于UI大小完全没有任何影响，只有实际设备的屏幕宽度会对UI大小产生影响。假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference Resolution状态下的x倍。也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸\n当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响。\n\nExpand：相当于设置 Canvas.scaleXY &#x3D; min(Screen.width &#x2F; ReferenceResolution.x, Screen.height &#x2F; ReferenceResolution.y)\n\nShrink：相当于设置 Canvas.scaleXY &#x3D; max(Screen.width &#x2F; ReferenceResolution.x, Screen.height &#x2F; ReferenceResolution.y)\n\n\n\n\n\n\n3.Graphic Raycaster组件基于射线的图形射线投射器，类似的射线组件有Physics Raycaster和Physics Raycaster2D，他们都依赖Camera组件。创建Canvas时一般会自带有这个组件，若没有这个组件则没办法响应点击等事件。Graphic Raycaster本身只会检测Canvas里的元素。因为GraphicRaycaster原本就在Canvas上了，所以在UI挂载的脚本上继承IEventSystemHandler事件接口，就能接收到回调，\n对于Graphic Raycaster比较重要的一个结构体是PointerEventData，它存在于EventSystems命名空间下，里面存储了当前鼠标（触点）的各项数值，例如鼠标的当前位置，点击的位置等。投射器的Raycast方法根据PointerEventData来发射射线，依靠这项原理可以解决鼠标的穿透问题。例子：\nbool CheckGuiRaycastObjects()\n    &#123;\n\t\t//构建一个关于鼠标点击的结构体\n        PointerEventData eventData = new PointerEventData(events);\n        eventData.pressPosition = Input.mousePosition;\n        eventData.position = Input.mousePosition;\n\n        List&lt;RaycastResult> list = new List&lt;RaycastResult>();\n        graph.GetComponent&lt;GraphicRaycaster>().Raycast(eventData, list);\n        Debug.Log(list.Count);\n        return list.Count > 0;\n    &#125;\n\n此外里面还有些可以设置屏蔽对象不参与射线检测的参数，指定阻止对某些layers进行响应等。\n4.EventTrigger输入事件触发器，与此脚本绑定的UI物体都可以接受输入事件。这个本身也是个类，它的内部继承了所有派生自IEventSystemHandler的接口，并将继承实现的函数写成虚函数。所以需要像上面的所述Canvas挂载Graphic Raycaster。若要上面的接口运用3D 2D物体元素上，则需要在摄像机上挂载PhysicsRaycaster或者Physics2DRaycaster。\n5.Image组件,RawImage组件两个都是UI系统里的主要组件，可以展示图片和图集。Image组件只能展示图集里的图元，因为是图集里的图片可以进行合批。RawImage可以展示单张图片，不能参与合批。一般来说使用RawImage的图片都是因为尺寸过大，参与图集合并会把图集也撑得很大，效率不高，所以干脆直接用RawImage来展示。\n6.Mask组件和RectMask2D组件遮挡组件，可以将其子节点下矩形区域外的内容剔除，是滚动窗口中最常用的组件。\n这两种方式的主要是在剔除的方法上有所区别，在实现效果上都是一样的，其中Mask 使用顶点重构的方式剔除矩形区域外的部分（使用了模板测试）而RectMask2D则采用Shader的剔除方式，每个元素都有自己的材质球实例和实例参数。\n源码部分UGUI系统大致可以分为3类，分别是输入检测模块，动画，核心渲染。\n输入检测模块输入事件可以分为事件数据模块，输入事件捕获模块，射线碰撞检测模块，事件逻辑处理及回调模块。EventSystem管理 所有的输入检测模块（InputModule）并帧调用Module的执行（Process）\n​调动射线捕捉模块（Raycasters），为InputModule提供结果（具体的触点所穿透的对象信息）\n​InputModule 管理更新EventData 判断当前的操作事件，并通知具体的EventSystemHandler 进行逻辑处理。\n事件数据模块这部分模块用于存储用户输入信息，包含事件发生时的位置、和事件对应的物体，事件的位移大小，触发事件的输入类型，以及事件的设备信息等。模块的主要作用就是获取数据，提供数据服务。\n这部分模块的基类是AbstractEventData，这个抽象基类内容不多，主要是围绕事件数据是否被使用过，有方法和变量描述是否已使用的状态。由它派生出\n\nBaseEventData：基础的事件数据基类，提供对事件系统角色的引用(绑定EventSystem)，和使用EventSystem的捕获模块获得当前选中的对象(BaseInputModule)的方法。\nPointerEventData：点位(指针)事件类型类，这个用处较多。Unity将按下的点位，鼠标或者触摸的点位，是否拖拽，是否移动，接收响应的物体等都存在里面。\nAxisEventData：滚轮事件数据类，这个代码量较少，只提供滚轮的方向信息。\n\n输入事件捕获模块输入事件捕获模块由四个类组成，BaseInputModule，PointerInputModule，StandaloneInputModule，TouchInputModule，负责引发事件并将其发送到 GameObjects 进行处理。在我看来这部分的理解，应该是\n认识基类拓展出去的方法理清触摸-&gt; 点击 这套流程里输入事件捕获模块做过什么事情。\n一般来说EventSystem下会挂载StandaloneInputModule或者TouchInputModule。\n捕获模块的基类是BaseInputModule，继承自EventSystems.UIBehaviour这个基类强依赖于EventSystem类，需要对象挂载EventSystem。提供了一些必要的接口和成员变量。\n里面有几个较为重要的方法可以一提，\n//update每帧都会调用它，最主要的方法，派生类在 Progress 方法中，\n//因为鼠标模拟层的原因，触摸需要先进行判断，然后根据判断是否有鼠标（input.mousePresent），进行鼠标事件处理。\npublic abstract void Process();\n\n//可用于返回第一个合法的RaycastResult,接收射线检测到的物体各类信息。\nprotected RaycastResult FindFirstRaycast(List&lt;RaycastResult>)&#123;&#125;\n\n//给定两个对象，返回他们最近的共同根物体。\nGameObject FindCommonRoot(GameObject g1,GameObject g2)&#123;&#125;\n\n//当发现新的输入目标时处理正在发送的进入和退出事件，会从PointerEventData参数里找到响应的对象，\n//并使用ExecuteEvents.Execute传递事件到对象里执行\nvoid HandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget)&#123;&#125;\n\n//具有给定 ID 的指针是否位于 EventSystem 对象上，这个方法主要由EventSystem.IsPointerOverGameObject调用过来。\npublic void IsPointerOverGameObject(int pointerId)&#123;&#125;\n由它派生出\n\nPointerInputModule：  这部分主要在其基础上扩展了对与点位的输入逻辑，增加了输入类型和状态，也是个抽象类。  比较重要的是定义了鼠标指针的ID，这样可以通过ID来判断是左键还是右键。\n//建立指针id与PointerEventData数据处理的字典\nprotected bool GetPointerData(int id, out PointerEventData data, bool create)&#123;&#125;\n\n//获得触摸的PointerEventData信息，触发EventSystem.RaycastAll，将射线信息存入PointerEventData返回\nprotected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released)&#123;&#125;\n\n//使用EventSystem的RaycastAll射线，获得射线碰撞的对象，并且返回保存按键数据的MouseState类\nprotected virtual MouseState GetMousePointerEventData()&#123;&#125;\n\n//还有ProcessDrag等，判断指针的状态(移动还是拖拽),执行对应方法(HandlePointerExitAndEnter或者直接ExecuteEvents.Execute)\nprotected virtual void ProcessMove(PointerEventData pointerEvent)&#123;&#125;;\n\n\n\n由PointerInputModule又派生出下面几个部分\n\nStandaloneInputModule：最直接的与EventSystem交流的类，EventSystem通过调用同对象下的Module类来调用功能。里面定义了鼠标&#x2F;键盘的输入。\n\n\n//EventSystem每帧都会调用这个函数\npublic override void Process()&#123;&#125;\n\n//检测触点，会在对象下挂载一个BaseInput类，这个检测类会调用Input里的各种函数，来得到触点或者鼠标位置之类的东西。\nprivate bool ProcessTouchEvents()&#123;&#125;\n\n//处理所有的鼠标事件,先调用GetMousePointerEventData,调用了各种ProcessXXX函数\npublic void ProcessMouseEvent(int id)&#123;&#125;\n\n\n\nTouchInputModule：和上面的差不多\n\n期间大量使用了ExecuteEvents.ExecuteHierarchy，ExecuteEvents.Execute，用以传输事件到相应对象里。\n//\npublic static GameObject ExecuteHierarchy&lt;T>(GameObject root, BaseEventData eventData, EventFunction&lt;T> callbackFunction) where T : IEventSystemHandler\n&#123;\n // 获取物体的所有父节点，包括它自己\n    GetEventChain(root, s_InternalTransformList);\n\n    for (var i = 0; i &lt; s_InternalTransformList.Count; i++)\n    &#123;\n        var transform = s_InternalTransformList[i];\n        // 对每个父节点包括自己依次执行句柄响应\n        if (Execute(transform.gameObject, eventData, callbackFunction))\n            return transform.gameObject;\n    &#125;\n    return null;\n&#125; \n\n\n射线碰撞检测模块射线碰撞检测模块主要工作是从摄像机的屏幕位置上，做射线碰撞检测并获取碰撞结果，把结果返回给事件处理逻辑类，交由事件处理模块处理事件。射线碰撞检测模块主要为3个类，分别作用于2D射线碰撞检测，3D射线碰撞检测，GraphicRaycaster图形射线碰撞测试。\n事件逻辑处理及回调模块核心渲染模块","slug":"对UGUI系统的理解","date":"2022-11-22T13:50:59.000Z","categories_index":"Unity","tags_index":"UI,基础","author_index":"HalfReunion"},{"id":"6d90e9563a794d3204e8d9a75ad8b2a9","title":"Unity的异步编程","content":"这里只打算探索一下Unity的协程实现和C#的原生异步实现：async&#x2F;await还有将async&#x2F;await整合进Unity生命周期的第三方库UniTask。\n1. Unity的协程Unity的协程依赖于IEnumertor类的迭代原理和Mono的生命周期，以实现一种分帧操作来呈现异步的效果。\nUnity协程的生命依靠着几个关键词IEnumertor,yield return。 启动一般以StartCoroutine()开始，\nIEnumertor的内部\npublic interface IEnumertor&#123;\n    public bool MoveNext();\n    public object Current &#123; get; &#125;\n    public void Reset();\n&#125;  \n当打算使用协程时，一般是声明一个函数迭代器(或者叫迭代器块)，然后使用yield return来控制函数执行的流程。\n这里也可以再详细研究一下，首先函数迭代器里只能用yield return而不是普通的return，其二是函数迭代器内部的实现，看似是一个按着顺序执行的结构，实际是让编译器生成了一个状态机。\n这个状态机的特性：\n\n拥有1个初始状态。\n每次调用MoveNext，在执行到yield return 语句前，它需要执行GetEnumerator方法中的代码。\n在使用到Current属性时，必须返回生成的上一个值。\n必须知道什么时候完成生成值的操作，以便MoveNext返回false。\n\n使用1个例子来描述(来源于C# in Depth)例如:\npublic static IEnumerator&lt;int> CreateEnumerable()&#123;\n        Console.WriteLine($\"&#123;Padding&#125; 开始调用 CreateEnumerable()\");\n        for(int i=1;i&lt;4;i++)\n        &#123;\n            Console.WriteLine($\"&#123;Padding&#125;准备调用yield &#123;i&#125;\");\n            yield return i*2;\n            Console.WriteLine($\"&#123;Padding&#125; yield 结束\");\n        &#125;\n        Console.WriteLine($\"&#123;Padding&#125; yiled 最后1个值\");\n        yield return -1;\n        Console.WriteLine($\"&#123;Padding&#125;CreateEnumerable() 结束\"); \n    &#125;\n\n    public static void TestBegin()&#123;\n        IEnumerator&lt;int> iterator = CreateEnumerable();\n        //IEnumerator&lt;int> iterator = iterable.GetEnumerator();\n        Console.WriteLine(\"开始递归\");\n        while(true)&#123;\n            Console.WriteLine(\"调用MoveNext\");\n            bool result = iterator.MoveNext();\n            Console.WriteLine($\"MoveNext的值=&#123;result&#125;\");\n            if(!result)&#123;\n                break;\n            &#125;\n            Console.WriteLine(\"Fetching Current...\");\n            Console.WriteLine($\"Current的值=&#123;iterator.Current&#125;\");\n            \n        &#125;\n    &#125;\n\n输出的结果为,\n在函数的正常使用里，return 基本有两个用处：为调用者提供返回值，终止方法的执行，在退出时执行finally代码块。\n上面的例子可以发现几个规律，\n\nyield return会临时退出方法，而当执行MoveNext的时候，yield return 会继续执行。\n所有工作在调用MoveNext时完成，获取current值(yield return 后面的值 是赋值给current属性)。\n需要通过MoveNext返回false才能结束方法执行。\n\n这样可以得到yield return的流程:-&gt;声明IEnumerator代码块-&gt;执行MoveNext()&#x3D;代码块执行到下一个yield return 临时退出方法-&gt;执行MoveNext()&#x3D;从刚才的退出的地方执行到下一个yield return,然后临时退出方法-&gt;执行MoveNext()-&gt; Loop -&gt; ……. 直到MoveNext返回false\n有关于为什么yield return也能用在IEnumerable里，C# in Depth作者对此有解析,https://csharpindepth.com/Articles/IteratorBlockImplementation\n那么为什么yield 可以Keep住状态，然后在下次继续执行呢？这里可以反编译一下yield 语法糖。\n\n反编译\n\npublic class Program\n&#123;\n\t[CompilerGenerated]\n\tprivate sealed class &lt;CreateEnumerable>d__2 : IEnumerator&lt;object>, IEnumerator, IDisposable\n\t&#123;\n\t\tprivate int &lt;>1__state;\n\n\t\tprivate object &lt;>2__current;\n\n\t\tprivate int &lt;i>5__1;\n\n\t\tobject IEnumerator&lt;object>.Current\n\t\t&#123;\n\t\t\t[DebuggerHidden]\n\t\t\tget\n\t\t\t&#123;\n\t\t\t\treturn &lt;>2__current;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tobject IEnumerator.Current\n\t\t&#123;\n\t\t\t[DebuggerHidden]\n\t\t\tget\n\t\t\t&#123;\n\t\t\t\treturn &lt;>2__current;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t[DebuggerHidden]\n\t\tpublic &lt;CreateEnumerable>d__2(int &lt;>1__state)\n\t\t&#123;\n\t\t\tthis.&lt;>1__state = &lt;>1__state;\n\t\t&#125;\n\n\t\t[DebuggerHidden]\n\t\tvoid IDisposable.Dispose()\n\t\t&#123;\n\t\t&#125;\n\n\t\tprivate bool MoveNext()\n\t\t&#123;\n\t\t\tswitch (&lt;>1__state)\n\t\t\t&#123;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\tcase 0:\n\t\t\t\t&lt;>1__state = -1;\n\t\t\t\tConsole.WriteLine(Padding + \" 开始调用 CreateEnumerable()\");\n\t\t\t\t&lt;i>5__1 = 1;\n\t\t\t\tgoto IL_00b6;\n\t\t\tcase 1:\n\t\t\t\t&lt;>1__state = -1;\n\t\t\t\tConsole.WriteLine(Padding + \" yield 结束\");\n\t\t\t\t&lt;i>5__1++;\n\t\t\t\tgoto IL_00b6;\n\t\t\tcase 2:\n\t\t\t\t&#123;\n\t\t\t\t\t&lt;>1__state = -1;\n\t\t\t\t\tConsole.WriteLine(Padding + \"CreateEnumerable() 结束\");\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t\tIL_00b6:\n\t\t\t\tif (&lt;i>5__1 &lt; 4)\n\t\t\t\t&#123;\n\t\t\t\t\tConsole.WriteLine(string.Format(\"&#123;0&#125;准备调用yield &#123;1&#125;\", Padding, &lt;i>5__1));\n\t\t\t\t\t&lt;>2__current = &lt;i>5__1 * 2;\n\t\t\t\t\t&lt;>1__state = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t&#125;\n\t\t\t\tConsole.WriteLine(Padding + \" yiled 最后1个值\");\n\t\t\t\t&lt;>2__current = -1;\n\t\t\t\t&lt;>1__state = 2;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tbool IEnumerator.MoveNext()\n\t\t&#123;\n\t\t\t//ILSpy generated this explicit interface implementation from .override directive in MoveNext\n\t\t\treturn this.MoveNext();\n\t\t&#125;\n\n\t\t[DebuggerHidden]\n\t\tvoid IEnumerator.Reset()\n\t\t&#123;\n\t\t\tthrow new NotSupportedException();\n\t\t&#125;\n\t&#125;\n\n\tprivate static readonly string Padding = new string(' ', 30);\n\n\tpublic static void Main(string[] args)\n\t&#123;\n\t\tProgram program = new Program();\n\t\tTestBegin();\n\t&#125;\n\n\t[IteratorStateMachine(typeof(&lt;CreateEnumerable>d__2))]\n\tpublic static IEnumerator CreateEnumerable()\n\t&#123;\n\t\treturn new &lt;CreateEnumerable>d__2(0);\n\t&#125;\n\n\tpublic static void TestBegin()\n\t&#123;\n\t\tIEnumerator iterator = CreateEnumerable();\n\t\tConsole.WriteLine(\"开始递归\");\n\t\twhile (true)\n\t\t&#123;\n\t\t\tConsole.WriteLine(\"调用MoveNext\");\n\t\t\tbool result = iterator.MoveNext();\n\t\t\tConsole.WriteLine(string.Format(\"MoveNext的值=&#123;0&#125;\", result));\n\t\t\tif (!result)\n\t\t\t&#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tConsole.WriteLine(\"Fetching Current...\");\n\t\t\tConsole.WriteLine(string.Format(\"Current的值=&#123;0&#125;\", iterator.Current));\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n可以看到，整个MoveNext变成了通过状态代码切换状态的函数，并分割成了几部分。成员变量\n5__1：指的是for循环里的i变量\n&lt;&gt;2__current：就是IEnumertor的current属性，这里我使用了int泛型，所以这里的类型变成了int。如果没有指定类型，这个变量将会是个Object。\n&lt;&gt;1__state ：状态代码，这个值的初始化在static IEnumertor CreateEnumerable()中，初始值为0。\n这样看流程就很清晰，编译器将函数里的逻辑分成几个步骤并分配给不同状态码管理，而每次执行MoveNext都会推进这个状态码的切换，保持yield return部分更新Current属性的同时，进而推进逻辑的执行。\n\n之后就是Unity部分，Unity部分涉及1个StartCorountine启动协程还有很多个yield return new XXXX。\nStartCoroutine将入参的IEnumerator包裹成Corountine对象，之后这个对象会保存在MonoBehaviour的一个成员容器里，同时内部还会提取出MoveNext和Current以方便调用，然后调用Corountine内部的run方法启动。从上面得知调用MoveNext就等同于推进逻辑执行，而Current主要是保存另一个yield return new XXXX的东西。\n\nWaitForSeconds\nWaitForFixedUpdate\nWaitForEndOfFrame\nCoroutine (C#层)\nWWW\nAsyncOperation\n\n这些类型的处理方式，无非是做个类似定时器一样的类DelayedCallManager去实现他们，比如说yield return new WaitForSeconds(10f)，DelayedCallManager根据这个需要等待的值直接去Update里算时间，计时结束后再回调Coroutine。\n\n别人对DelayedCallManager的解析\n\n\n\tvoid DelayedCallManager::Update()\n&#123;\n\tfloat time = GetCurTime();\n\tint frame = GetTimeManager().GetFrameCount();\n\t\n\tContainer::iterator iterator = m_CallObjects.begin (); //m_CallObjects保存了所有注册的Coroutine对象\n\t\n\t// iterator->time 在注册的时候赋值是: 当前时间 + 等待的时间(new WaitForSeconds(5),那么就是5秒)\n\t// iterator->time &lt;= time 这个条件判断了iterator的定时时间是否满足了\n\t// 比如上面我们加入定义new WaitForSeconds(5)，\n\t// 满足的条件时就当当前时间time要大于iterator满足的时间的时候，则进入这个while循环内\n\twhile (iterator !=  m_CallObjects.end () &amp;&amp; iterator->time &lt;= time) \n\t&#123;\n\t\t//判断帧是否满足,加入用到了new WaitForFixedUpdate()之类的\n\t\tif (cb.timeStamp != m_TimeStamp &amp;&amp; cb.frame &lt;= frame) \t\t&#123;\n\t\t\t//调用CoroutineCallback了\n\t\t&#125;\t\n\t&#125;\n&#125;\n\n\n\n2. async&#x2F;await去看了看Unity课堂的日本站，有关于异步处理的专栏，几乎都是async&#x2F;await的讲解，看下他们的解析来总结。\n\nasync关键字：指定方法为异步方法。\nawait关键字：用于修饰async方法里的逻辑，await是阻塞的，若无返回则不会执行下面的操作。\n\n用简单的例子展开：\nstatic async void AsyncTest()\n&#123;\n\tConsole.WriteLine(DateTime.Now);\n\tawait Task.Delay(5000);\n\tConsole.WriteLine(DateTime.Now);\n&#125;\n反编译这段代码，可以发现内部是创建了一个状态机，用比较清晰的写法来描述这段\nprivate static void AsyncTest()&#123;\n\t//实例化1个异步状态机\n\tvar statemachine = new AsyncTestStateMachine();\n\t\n\tstateMachine.builder = AsyncVoidMethodBuilder.Create();\n\tstateMachine.state = -1;\n\tstateMachine.state = -1;\n\tstateMachine.builder.Start(ref stateMachine);\n&#125;\nAsyncTestStateMachine是一个名字是动态生成，继承自IAsyncStateMachine的类，MSDN对这个接口的解释是 表示为异步方法生成的状态机。 此类别仅供编译器使用。 需要实现一个MoveNext()作为状态转换函数，有一个重要的成员对象AsyncVoidMethodBuilder。\n\nAsyncTestStateMachine的反编译\n\nprivate sealed class &lt;asyncFunc>d__1 : IAsyncStateMachine\n\t&#123;\n\t\tpublic int &lt;>1__state;\n\n\t\tpublic AsyncVoidMethodBuilder &lt;>t__builder;\n\n\t\tprivate TaskAwaiter &lt;>u__1;\n\n\t\tprivate void MoveNext()\n\t\t&#123;\n\t\t\tint num = &lt;>1__state;\n\t\t\ttry\n\t\t\t&#123;\n\t\t\t\tTaskAwaiter awaiter;\n\t\t\t\tif (num != 0)\n\t\t\t\t&#123;\n\t\t\t\t\tConsole.WriteLine(DateTime.Now);\n\t\t\t\t\tawaiter = Task.Delay(5000).GetAwaiter();\n\t\t\t\t\tif (!awaiter.IsCompleted)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tnum = (&lt;>1__state = 0);\n\t\t\t\t\t\t&lt;>u__1 = awaiter;\n\t\t\t\t\t\t&lt;asyncFunc>d__1 stateMachine = this;\n\t\t\t\t\t\t&lt;>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tawaiter = &lt;>u__1;\n\t\t\t\t\t&lt;>u__1 = default(TaskAwaiter);\n\t\t\t\t\tnum = (&lt;>1__state = -1);\n\t\t\t\t&#125;\n\t\t\t\tawaiter.GetResult();\n\t\t\t\tConsole.WriteLine(DateTime.Now);\n\t\t\t&#125;\n\t\t\tcatch (Exception exception)\n\t\t\t&#123;\n\t\t\t\t&lt;>1__state = -2;\n\t\t\t\t&lt;>t__builder.SetException(exception);\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\t&lt;>1__state = -2;\n\t\t\t&lt;>t__builder.SetResult();\n\t\t&#125;\n\n\t\tvoid IAsyncStateMachine.MoveNext()\n\t\t&#123;\n\t\t\t//ILSpy generated this explicit interface implementation from .override directive in MoveNext\n\t\t\tthis.MoveNext();\n\t\t&#125;\n\n\t\t[DebuggerHidden]\n\t\tprivate void SetStateMachine(IAsyncStateMachine stateMachine)\n\t\t&#123;\n\t\t&#125;\n\n\t\tvoid IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)\n\t\t&#123;\n\t\t\t//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine\n\t\t\tthis.SetStateMachine(stateMachine);\n\t\t&#125;\n\t&#125;\n\n\n这个状态机内部有几个成员变量:&lt;&gt;1__state \t\t当前状态机的状态&lt;&gt;t__builder \t主要负责异步方面操作的核心成员变量。这里的类型是AsyncVoidMethodBuilder，表示不返回值的异步方法生成器。&lt;&gt;u__1\t\t\tTaskAwaiter类型，提供等待异步任务完成的对象。\n流程上是，编译器为所有被async修饰的异步方法，构建继承自IAsyncStateMachine的状态机，每个状态机都新增一个初始化的方法，这个方法用于初始化 builder 成员，将初始状态设置为 -1，并且会调用builder的start，调用MoveNext。若有async嵌套async的情况，最外层的async会获得下一层async的awaiter，并且对其进行等待回调操作。\n进入MoveNext，先判断状态是否为0，\n否：获取Task异步方法的Awaiter，并判断异步是否已经完成\n未完成：则将状态置为0，把Awaiter存入类成员变量中，并以该awaiter和自身this作为入参调用builder的.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine)方法，然后退出状态机。AwaitUnsafeOnCompleted的作用是，待异步方法完成时回调状态机的MoveNext()方法。\n是：将状态设为-1，重置状态码，执行延迟后面的逻辑。\n深入到Task.Delay，内部主要通过System.Threading.Timer实现，本身是基于线程池线程实现，所以他的计时是开启线程-&gt;线程内计时-&gt;计时结束回调，Delay函数返回Task，而AsyncVoidMethodBuilder的机制使得他会等待计时完成再执行后面的逻辑，因为使用了多线程所以也没有阻塞到主线程。\nasync void和async Task区别https://docs.microsoft.com/zh-cn/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming\n3. UniTask","slug":"Unity的异步编程","date":"2022-07-12T16:36:41.000Z","categories_index":"Unity","tags_index":"探索发现,C#","author_index":"HalfReunion"},{"id":"d128f62f62d268410a7ff9276841ac04","title":"玩游戏-仁王2","content":"之前一段时间(半年前)在玩仁王2，实在是很有意思的游戏。有可玩性高的动作系统，换一把武器就能有截然不同体验的感觉和怪猎非常相似，然后还拥有一些刷刷刷，装备build的RPG要素。\n游戏里角色操作三段架势还有数种适配架势的技能，结合精力管控系统，再进行一些合理的玩法增添后，让人玩起来感觉非常顺滑且游刃有余，当然这是建立在偏后期，阴阳术和基本装备成型后才能达到的效果，游戏的前期体验在没有选对武器，加点思想不对的情况下还是非常吃苦（说的就是你，手甲），不过我以前玩过1代，所以对残心的使用还是比较知悉，至少说有使用它的习惯。\n精力系统的存在我认识是对游戏内RPG要素的一个妥协，也可能算是种历史遗留问题，毕竟1代的时候光荣脱裤魔是有些碰瓷宣传的，碰的是目前还在大热的魂系，估计当时组内也是以制作一款类魂游戏为目的去制作，当然了，游戏本身最大的成功还是要归功于忍者组深厚的ACT游戏制作功底，不管怎么说也是经历过忍龙的组，而现在很多类魂3D游戏，也不是每款都像仁王那么独一档。（迸发，堕落之王，Mortal Shell，CODE VEIN等），当然我是认为凭借这套动作系统，完全可以摆脱这套精力系统，去做更自由的变化。\n目前玩的时候是时间是\n\n\n仁王1的进度还在DLC里，还是大学时期玩的，估计是不会再碰。而仁王2在5周目后直接打奈落狱，进度是第30层。\n因为我主用手甲，也没换过武器，所以下面的体验以手甲为主：\n手甲最大的使用体验在于需要你使用不同武技去叠加名为“连绵”的buff，这个buff能增加伤害，因为本身手甲动作发生比较快，所以作为补偿伤害也会相应低一些，所以十分依靠连绵buff带来的伤害补足，也因此叠加连绵层数期间会让人觉得十分拖沓，暖机机制也不是所有人都喜欢。连绵buff最多有10层，且层数越高buff存在的时间就越短，如何快速叠加连绵，且在连绵buff生效期间去打出高伤害，就成为了重中之重的技巧，叠不起buff的话伤害就会非常刮痧，体验极差。由于手甲的动作十分之快，所以在连续攻击的情况下切换架势去释放不同战技，也不会有停顿感，更别说一些战技拥有位移闪避的效果，配合高层数连绵和混沌debuff，打起来还是非常赏心悦目的。\n混沌debuff又是这个游戏里面比较重要的玩法，混沌debuff的效果是增加玩家伤害，和阻止妖怪进入常暗。 这一作的妖怪型敌人在妖力槽被清空前都处于霸体状态，只有在妖力槽清空后玩家攻击才会造成硬直。在妖力槽清空的一段时间后或者妖怪从可处决状态里恢复过来，就会自动进入常暗，特效是玩家所见都变成黑白，玩家精力槽回复变慢，妖怪恢复大部分妖力槽且增加很多招式且保持霸体。若能在妖怪进常暗前让妖怪进入混沌的debuff状态，就能在妖怪倒地处决前不进入常暗。\n混沌debuff需要让对面积累两种异常属性（不包括麻痹和毒），一般来说武器可以附魔增加一种属性，而另一种属性就要依靠阴阳术（类似法术一样的存在）。所以这也是这个游戏里“阴阳武者”这件套装十分风靡的原因，阴阳武者的神宝套装效果，可以恢复玩家最后一次释放的阴阳术的数量，搭配一些强力阴阳术，能让受苦度大量下降。\n当然进入常暗状态对玩家也不是一件完全有害的事，进入常暗后攻击妖怪能大幅度增加自己的妖力槽，而妖力槽是释放妖怪技的必须能量。所以也存在进入常暗后，无限释放妖怪技的build。\n所以现在很期待忍者组的下一部三国题材的作品。下一个游戏想玩arc system的ggst。\n今天听的歌是 Forever Yours feat. Stacy Epps &amp; Toby from Inverse (re-plus remix)https://music.163.com/song?id=22762850\n","slug":"玩游戏-仁王2","date":"2022-07-04T11:26:58.000Z","categories_index":"随笔","tags_index":"玩游戏","author_index":"HalfReunion"},{"id":"ce2b5aade03ea809a40872ba12728878","title":"ET框架学习_ETBook阅览(慢慢更)","content":"加了ET群很久，一直只是看群里的人聊天谈地，clone了ET框架很长时间，也没有怎么看过，所以这次想先从ETBook开始看起，认识一下这个框架。\nETBook地址:http://etgame.cn/pages/a2f161/\n在这次的ETBook阅读的同时，我也会同步看烟雨迷离半世殇的ETBook笔记汇总，加深理解。\n烟雨迷离半世殇的ETBook笔记汇总：https://www.lfzxb.top/etbook/\n目前的git上的master分支已经更到了7.0，该版本似乎还在持续更新中，不知道有多大的时效性。\n略过前面的介绍，直接从第二章:CSharp的协程开始。\n\n2.CSharp的协程2.1 CSharp的协程作者在开篇使用一段while循环+线程挂起的程序。并以此做延伸来引出异步的实现。\nprivate static void Main()\n   &#123;\n       int loopCount = 0;\n       while (true)\n       &#123;\n           int temp = watcherValue;\n           \n           Thread.Sleep(1);\n           \n           ++loopCount;\n           if (loopCount % 10000 == 0)\n           &#123;\n               Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n           &#125;\n       &#125;\n   &#125;\n为了做出延时5秒后输出loopCount的效果，且不打断10000次计数打印一次的逻辑，这里导入ET框架中的一个自定义单例OneThreadSynchronizationContext，这个类主要处理别的线程扔回主线程的委托。简短介绍一下该类的成员和方法。\n\nOneThreadSynchronizationContext\n\n//SynchronizationContext 提供了1个Post虚函数。\npublic class ThreadSynchronizationContext : SynchronizationContext&#123;\n    // Instance单例访问器\n    public static ThreadSynchronizationContext Instance;       \n\n    // 用于存储主线程的线程ID,在构造函数里初始化\n    private readonly int threadId ;\n    \n    // 线程同步队列,发送接收socket回调都放到该队列,由poll线程统一执行\n    // 一个线程安全的只读队列,存储Action。\n    private readonly ConcurrentQueue&lt;Action> queue;\n\n    //用于存储从队列里提取的Action委托\n    private Action a;\n\n    //一个轮询用的函数,\n    public void Update()&#123;\n        while(true)&#123; \n\n             //此处提取queue里的委托,若无则return;\n            if(!TryDequeue(out a))&#123;\n               \n                return;\n            &#125; \n            //执行Action委托 \n            a();\n        &#125;\n    &#125;\n\n    //覆写SynchronizationContext的虚函数Post\n    public override void Post(SendOrPostCallback callback, object state)\n    &#123;   //用了一个匿名函数\n        this.Post(() => callback(state));\n    &#125; \n\n    public void Post(Action action)\n    &#123;\n        //首先会判断当前Thread线程的ID是否与此单例的线程ID相同\n        if(Thread.CurrentThread.ManagedThreadId == this.threadId)\n        &#123;\n            //若相同,说明目前在主线程,则执行参数action\n            callback(state);\n            return;\n        &#125; \n\n    //否则将其他线程来的action委托入队queue\n        PostNext(callback);\n    &#125;\n\n    //用于将参数action入队\n    public void PostNext(Action action)\n    &#123;\n        this.queue.Enqueue(() => &#123; callback(state); &#125;);\n    &#125; \n&#125;\n\n\n而后作者设计出了一个异步方法，这个方法核心在于：另开一个线程，并将逻辑包裹成委托传入，使用Thread.Sleep做阻塞n秒的操作，待阻塞完毕后将委托扔回主线程执行，这样就能在不阻塞主线程的情况下作一个计时操作，也避免了一些线程冲突操作，且免去加锁的麻烦。\n\nprivate static void Main()\n&#123;\n    WaitTimeAsync(5000,WaitTimeFinishCallback);\n    //时刻轮询\n    while(true)&#123;\n        ThreadSynchronizationContext.Instance.Update();\n    &#125;\n&#125;\n\nprivate static void WaitTimeFinishCallback()&#123;\n    WaitTimeAsync(4000,WaitTimeFinishCallback);\n&#125;\n\nprivate static void WaitTimeAsync(int waitTime,Action action)&#123;\n    \n    Thread thread = new Thread(()=> WaitTime(waitTime,action));\n    thread.Start();\n&#125;\n\nprivate static void WaitTime(int waitTime,Action action)\n&#123;\n    //在新的线程里休眠等待\n    Thread.Sleep(waitTime);\n    //休眠完事后把委托扔进去\n    OneThreadSynchronizationContext.Instance.Post(o=>action(),null);\n&#125;\n\n\n\n2.2 更好的协程使用上面的方法如果有增加的需求会不方便。这时候可以用C#自带的异步语法。此处使用了C#设计的几个逻辑\n\nTask\nasync&#x2F;await\nTaskCompletionSource\n\n1.Task可以理解为，为了一个异步操作而封装了多种功能的集合单位，本质还是使用了Thread，MSDN直接解释为一个异步操作。而Thread更倾向于是一个最基本的线程单元。\n2.async&#x2F;await是一对组合使用的关键字，async用于修饰方法，用于提醒该方法里有异步操作，而await用于修饰async方法里的逻辑，await是阻塞的，若无返回则不会执行下面的操作。\n3.TaskCompletionSource，是一种创建Task的方式。集合了控制Task的方法。\nprivate static void WaitTimeAsync(int waitTime, Action action)\n&#123;\n    Thread thread = new Thread(()=>WaitTime(waitTime, action));\n    thread.Start();\n&#125;\n\n//此处把action回调略去,改为使用TaskCompletionSource\nprivate static Task WaitTimeAsync(int waitTime)\n&#123;\n    TaskCompletionSource&lt;bool> tcs = new TaskCompletionSource&lt;bool>();\n    Thread thread = new Thread(()=>WaitTime(waitTime, tcs));\n    thread.Start();\n    return tcs.Task;\n&#125;\n改变了之前需要回调方法里嵌套回调来实现的连续异步操作。\nprivate static async void Crontine()\n&#123;\n    await WaitTimeAsync(5000);\n    Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n    await WaitTimeAsync(4000);\n    Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\"); \n&#125;\n\n//旧的形式\npublic static void main()&#123;\n    WaitTimeAsync(5000, WaitTimeFinishCallback);\n&#125;\n\nprivate static void WaitTimeFinishCallback()\n&#123;\n    Console.WriteLine($\"WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n    WaitTimeAsync(4000, WaitTimeFinishCallback2);\n&#125;\n此时作者在主线程调用了这个静态函数：SynchronizationContext.SetSynchronizationContext(OneThreadSynchronizationContext.Instance); 用于同步上下文，替换了将逻辑扔回主线程执行的操作，\n在WaitTime中直接调用tcs.SetResult(true)就行了，回调会自动扔到同步上下文中，而同步上下文我们可以在主线程中取出回调执行，这样自动能够完成回到主线程的操作\n private static void WaitTime(int waitTime, TaskCompletionSource&lt;bool> tcs)\n&#123;\n    Thread.Sleep(waitTime);\n\n    tcs.SetResult(true);\n&#125;\n\n2.3 单线程异步异步实现不仅仅只有多线程的方式，一般游戏逻辑会设计一个单线程的计时器。代码比较简单,直接贴出来了。\n\n单线程异步\n\nclass Program\n    &#123;\n        private static int loopCount = 0;\n\n        private static long time;\n        private static Action action;\n        \n        static void Main(string[] args)\n        &#123;\n            Console.WriteLine($\"主线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;\");\n\n            Crontine();\n            \n            while (true)\n            &#123;\n                Thread.Sleep(1);\n\n                CheckTimerOut();\n                \n                ++loopCount;\n                if (loopCount % 10000 == 0)\n                &#123;\n                    Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n                &#125;\n            &#125;\n        &#125;\n        \n        private static void Crontine()\n        &#123;\n            \n            WaitTimeAsync(5000, WaitTimeAsyncCallback1);\n        &#125;\n\n        //每次执行完都会刷新一次time和委托\n        private static void WaitTimeAsyncCallback1()\n        &#123;\n            Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n            \n            //刷新新的time和委托\n            WaitTimeAsync(4000, WaitTimeAsyncCallback2);\n        &#125;\n        \n        \n        private static void CheckTimerOut()\n        &#123;\n            if (time == 0)\n            &#123;\n                return;\n            &#125;\n            // 检测时间到了没有,若到了则执行。\n            long nowTicks = DateTime.Now.Ticks / 10000;\n            if (time > nowTicks)\n            &#123;\n                return;\n            &#125;\n\n            time = 0;\n            action.Invoke();\n        &#125;\n        \n        private static void WaitTimeAsync(int waitTime, Action a)\n        &#123;\n             \n            time = DateTime.Now.Ticks / 10000 + waitTime;\n            action = a;\n        &#125;\n    &#125;\n\n\n把上面的样子改成await形式\n\nawait异步\n\nclass Program\n&#123;\n    private static int loopCount = 0;\n\n    private static long time;\n    private static TaskCompletionSource&lt;bool> tcs;\n        \n    static void Main(string[] args)\n    &#123;\n        Console.WriteLine($\"主线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;\");\n\n        Crontine();\n            \n        while (true)\n        &#123;\n            Thread.Sleep(1);\n\n            CheckTimerOut();\n                \n            ++loopCount;\n            if (loopCount % 10000 == 0)\n            &#123;\n                Console.WriteLine($\"loop count: &#123;loopCount&#125;\");\n            &#125;\n        &#125;\n    &#125;\n        \n    private static async void Crontine()\n    &#123;\n        await WaitTimeAsync(5000);\n        Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\");\n        await WaitTimeAsync(4000);\n        Console.WriteLine($\"当前线程: &#123;Thread.CurrentThread.ManagedThreadId&#125;, WaitTimeAsync finsih loopCount的值是: &#123;loopCount&#125;\"); \n    &#125;\n\n    private static void CheckTimerOut()\n    &#123;\n        if (time == 0)\n        &#123;\n            return;\n        &#125;\n        long nowTicks = DateTime.Now.Ticks / 10000;\n        if (time > nowTicks)\n        &#123;\n            return;\n        &#125;\n\n        time = 0;\n        tcs.SetResult(true);\n    &#125;\n        \n    private static Task WaitTimeAsync(int waitTime)\n    &#123;\n        TaskCompletionSource&lt;bool> t = new TaskCompletionSource&lt;bool>();\n        time = DateTime.Now.Ticks / 10000 + waitTime;\n        tcs = t;\n        return t.Task;\n    &#125;\n&#125;\n\n\n\n代码简单，要注意的点是await不会开启多线程，这上面的调用都是在主线程中完成，有没使用多线程取决于具体实现，task在没有await的情况下是非阻塞的。我本身对这个不太熟悉，要去补补对应知识。\n3.2 强大的MongoBson库需要使用序列化的场景:\n\n对象通过序列化反序列化clone\n服务端数据库存储数据，二进制\n分布式服务端，多进程间的消息，二进制\n后端日志，文本格式\n服务端的各种配置文件，文本格式\n\n列举常用序列化库\n\nprotobuf不支持复杂的对象结构(无法使用继承)，做消息合适，做数据库存储和日志格式并不好用。\njson做日志格式合适，但是做网络消息和数据存储就太大。\n\n\n适用场景\n\n\n你想想某天你的配置文件需要放到数据库中保存，你不需要进行格式转换，后端直接把前端发过来的配置消息保存到数据库中，这是不是能减少非常多错误呢？\n某天有些服务端的配置文件不用文件格式了，需要放在数据库中，同样，只需要几行代码就可以完成迁移。\n某天后端服务器crash，你需要扫描日志进行数据恢复，把日志进行反序列化成C#对象，一条条进行处理，再转成对象保存到数据库就完成了。\n对象保存在数据库，直接就可以看到文本内容，可以做各种类sql的操作\n想像一个场景，一个配置文本对象，反序列化到内存，通过网络消息发送，存储到数据库中。整个过程一气呵成。、\n\n\n这里作者选用了Mongo Bson，可以减少各种数据转换，减少代码，提高可维护性。MongoDB库既可以序列化成文本也可以序列化成BSON的二进制格式。\n\nMongo Bson支持功能\n\n\n支持复杂的继承结构\n支持忽略某些字段序列化\n支持字段默认值\n结构多出多余的字段照样可以反序列化，这对多版本协议非常有用\n支持ISupportInitialize接口使用，这个在反序列化的时候简直就是神器\n支持文本json和二进制bson序列化\nMongoDB数据库支持\n\n\n\n后面是列举MongoBson的一些使用例子，推荐直接去官网看。\n3.3 一切皆组件本篇主要介绍ECS设计，OW(守望先锋)率先使用ECS这种设计并取得巨大成功。它采用了状态帧这种网络技术：即客户端服务器端拥有一套相同逻辑，客户端进行预测行为，先进行客户端表现，而后和服务器端的预测行为做对照，不匹配的话就进行回滚。（预测这个词我这里还是有点不太理解，后面还需要去查查。）使用组件式开发的话，则只需要回滚对应组件即可。\nECS的重点在于逻辑与数据完全分离，EC是纯数据，System是逻辑，由数据驱动逻辑。而数据驱动逻辑的意思即：通过Update（tick）检测数据变化，通过事件机制来订阅数据变化。\n作者认为传统的ECS书写逻辑的方式有让组件过于稀碎化的缺点，导致组件非常多且开发人员只熟悉自己的模块，造成大量冗余。Entity和Component通常只有一层，组件一多可能不知道要使用哪些Component。合理的做法是以树状的方式管理组件，Entity可以管理Component，Component管理Entity，甚至Component还可以挂载Component。例如：人由头，身体，手，脚组成，而头又由眼睛，耳朵，鼻子，嘴巴组成。\n在ET框架里，所有数据都是Component，包括Entity，Entity继承于ComponentWithId，ComponentWithId继承于Component，所以Entity本质上也是一个Component，只不过它可以挂载其它的Component。\n实际使用中可以继承Component，ComponentWithId，Entity三者之一，\n\n如果该类需要挂载组件则继承Entity。\n如果不需要挂载组件，但是需要带个逻辑ID则继承ComponentWithId。\n其他情况继承Component。\n\nET的Entity可以有数据成员，通用的数据放在Entity上作为成员，不通用的作为组件挂载在Entity上，比如物品的设计，所有物品都有配置id，数量，等级的字段，这些字段没有必要做成组件，放在Entity身上使用会更加方便。\n\nclass Item: Entity\n&#123;\n    // 道具的配置Id\n    public int ConfigId &#123; get; set; &#125;\n    // 道具的数量\n    public int Count &#123; get; set; &#125;\n    // 道具的等级\n    public int Level &#123; get; set; &#125;\n&#125;\n\nET的树状数据结构:顶层Game.Scene，不同模块的数据都挂载在Game.Scene上，每个模块下可以挂载很多数据。比如做一个道具系统，设计一个ItemsComponent挂载在Player上即可，需要技能开发一个SkillComponent挂载在Player上。全服需要做一个活动，则开发一个活动组件挂载到Game.Scene上，这种设计会十分简洁且模块化。\n组件的细节1.组件的创建组件的创建统一由ComponentFactory创建，该工厂类提供了Create,CreateWithParent,CreateWithId三个方式。其中Create是最简单的创建方式，它做了几个处理。\n\n根据组件类型构建一个组件。\n将组件加入事件系统，并且抛出一个AwakeSystem。\n是否启用对象池。\n\nCreateWithParent在Create基础上提供了一个Parent对象，设置到Component.Parent字段上。\nCreateWithId是用来创建ComponentWithId或者其子类的，在Create的基础上可以自己设置一个Id, Component在创建的时候可以选择是否使用对象池。\n三类工厂方法都带有一个fromPool的参数，默认是true。\n2.组件的释放Component有非托管资源，所以需要继承一个IDisposable接口，用于显示释放资源。使用该接口主要做如下操作\n\n抛出Destory System。\n如果组件是对象池创建的，那么在这里会放回对象池。\n从全局事件系统(EventSystem)中删除该组件，并且将InstanceId设为0。如果组件挂载Entity身上，那么Entity调用Dispose的时候会自动调用身上所有Component的Dispose方法。\n\n3.1 InstanceId的作用所有Component都存在一个InstanceID作为唯一标识，组件构建或者组件从对象池取出时重新设置。这个字段的存在意义如下。\n\n对象池的存在，使得组件未必会被释放，可能是回到对象池中。异步调用里很可能这个组件已经被释放了，然后又被重新利用起来，这样需要区分之前的组件对象是否已经被释放。\n public static async ETVoid UpdateAsync(this ActorLocationSender self)\n&#123;\n try\n &#123;\n  long instanceId = self.InstanceId;\n  while (true)\n  &#123;\n   if (self.InstanceId != instanceId)\n   &#123;\n    return;\n   &#125;\n\n   ActorTask actorTask = await self.GetAsync();\n\t\n   if (self.InstanceId != instanceId)\n   &#123;\n    return;\n   &#125;\n   if (actorTask.ActorRequest == null)\n   &#123;\n    return;\n   &#125;\n\n   await self.RunTask(actorTask);\n  &#125;\n &#125;catch (Exception e)\n &#123;\n  Log.Error(e);\n &#125;\n&#125;\n while (true)中是段异步方法，await self.GetAsync()之后很可能ActorLocationSender对象已经被释放了，甚至有可能这个对象又被其它逻辑从对象池中再次利用了起来。我们这时候可以通过InstanceId的变化来判断这个对象是否已经被释放掉。\n\nInstanceId是全局唯一，且带有位置信息，可以通过InstanceID来找到对象位置，将消息发给对象，这个设计将会在Actor消息中利用到。\n\n\n结合一下官方ET的DEMO来看看\n3.4 事件机制EventSystem","slug":"ET框架学习-ETBook阅览","date":"2022-06-30T04:24:40.000Z","categories_index":"通用","tags_index":"ET框架,探索发现,C#","author_index":"HalfReunion"},{"id":"0eeec1440f5c3f42f857474d88fef113","title":"UnityEngine.Object和System.Object","content":"引子\nstring s = string.Empty;\nvar go = new GameObject(\"goodBoy\");\n        \nDestroyImmediate(go);\ngo = null;\nif (!go) s += \"A\";\n\nif (go is null) s += \"B\";\n        \nif (go == null) s += \"C\";\n\nif ((System.Object)go == null) s += \"D\";\n\nDebug.Log(s);\n\n\n最后输出AC。\n首先而System.Object的&#x3D;&#x3D;null是判断是否为空指针，\n而UnityEngine.Object的”&#x3D;&#x3D;”是做过操作符重载的，当然也重载了≠。\nUnityEngine.Object的&#x3D;&#x3D;会调用以下的片段。\nprivate static bool CompareBaseObjects(Object lhs, Object rhs)\n&#123;\n\t//强转为System.object\n\t//操作符左边的值是否为null\n    bool flag = (object)lhs == null;\n\t//操作符右边的值是否为null\n    bool flag2 = (object)rhs == null;\n\n\t//都为null 返回true\n\t//此处说明，如果C#方面的引用已被置为空引用,那游戏对象肯定不存在.\n    if (flag2 &amp;&amp; flag)\n    &#123;\n        return true;\n    &#125;\n\t\t\t\t\t\t\n\t\t\t\t\t\t \n    if (flag2)\n\t&#123;\n        return !IsNativeObjectAlive(lhs);\n    &#125;\n\n    if (flag)\n    &#123;\n        return !IsNativeObjectAlive(rhs);\n    &#125;\n\t\t\t\t\t  \n\t//（通过对GUID和LocalID的计算，得到全局唯一的m_InstanceID）\n\t// 对比二者的m_InstanceID\n    return lhs.m_InstanceID == rhs.m_InstanceID;\n&#125;\n\n另一段是\nprivate static bool IsNativeObjectAlive(Object o)\n&#123;\nif (o.GetCachedPtr() != IntPtr.Zero)\n&#123;\n    return true;\n&#125;\n//判断对象是否派生自MonoBehaviour 或者 ScriptableObject\nif (o is MonoBehaviour || o is ScriptableObject)\n&#123;\n    return false;\n&#125;\n//判断InstanceID还存不存在\nreturn DoesObjectWithInstanceIDExist(o.GetInstanceID());\n\n&#125;\n\n得出结论：对于被Destory掉了的UnityEngine.Object对象（底层C++对象），上面挂载的代码已经不会继续执行，C#方面的引用变量是否置为空引用已经无关紧要。\n所以Unity重写了UnityEngine.Object的判空，只判断UnityEngine.Object是否被销毁（注意这个销毁让UnityEngine.Object不能继续执行它上面的代码），而不是C#引用是否被置为null。\n题外话：像是？和？？都是跟System.Object靠边的，慎用在UnityEngine.Object上。\n对于UnityEngine.Object被销毁后，C#层面的引用几时会置为空引用和实例几时被GC掉，这个有待考据。\n","slug":"UnityEngine-Object和System-Object","date":"2022-06-29T03:32:19.000Z","categories_index":"Unity","tags_index":"C#,基础","author_index":"HalfReunion"},{"id":"9f9e7828b8716ddb566b45d44fabc1de","title":"小技巧_u3d_C#","content":"1，使用Physics.OverlapSphereNonAlloc，不会像Physics.OverlapSphere那样创建出Collider[]数组出来，它生成的是一个int值类型，这意味着就不会分配内存空间，不会产生GC，很多检测都有NonAlloc，有些情况可以考虑使用这些OverLapXXXNonAlloc。\n2，对于两个脚本间互相调用，会遇到start与start间初始化时间存在乱序而空引用的错误，此时可以用访问器解决，\nxxx xx get&#123;\n\tif(_xx==null)&#123;\n\t\t_xx = GetComponent&lt;xxx>();\n\t&#125;\n\treturn _xx;\n&#125;\n\n3，yield return new 产生的GC问题。可以生成一个静态对象解决。\npublic static class YieldHelper\n&#123;\n\t\tpublic static WaitForEndOfFrame WaitForEndOfFrame = new WaitForEndOfFrame();\n\t\t\npublic static IEnumerator WaitForSeconds(float totalTime,bool ignoreTimeScale = false)\n&#123;\n\t\tfloat time = 0;\n\t\twhile(time &lt; totalTime)\n&#123;\n\t\ttime += (ignoreTimeScale?Time.unscaledDeltaTime:Time.deltaTime);\n\t  yield return null;\n&#125;\n&#125;\n&#125;\n\n4，enum : byte 的作用这个表示枚举元素使用 byte 存储。普通声明的话，是继承int。例 public enum Icon_Type : int继承自byte可以稍微减少一点内存占用。\n5，对比int比对比string效率更高，所以有些地方可以考虑用将字符串转化为哈希值再对比。当然可能有哈希冲突的风险。\n","slug":"小技巧_u3d_C#","date":"2022-06-28T09:02:08.000Z","categories_index":"Unity","tags_index":"C#","author_index":"HalfReunion"},{"id":"1350894a588790266d2094e5ec7bddd0","title":"UI的DrawCall计算","content":"总结提取自uwa4d的文章：https://edu.uwa4d.com/course-intro/0/126\n影响DrawCall的元素有三点：Depth值，Material，Texture。\nDepth值：\n\n需要按照Hierarchy面板的节点顺序，从上到下进行Depth分析。（使用深度优先原则）\n\n跳过不渲染的节点，比如active&#x3D;false，Canvas不渲染的Layer等（使其depth为-1）。\n\n如果处于渲染状态，但是Hierarchy面板的他下面没有其他元素跟他相交，其Depth值为0。\n\n\n不是RectTransform的Rect相交，而是渲染元素有没有重叠。\n\n\n如果有相交，找到其中最大depth值(把值记作MaxLowerDepth)的元素，判断是否能与相交的合批\n\n（即Batch，条件为Material和Textrue相同），如果能，则当前depth值&#x3D;MaxLowerDepth。\n若不能Batch，则相交的depth值&#x3D;MaxLowerDepth+1。（计算可从最底层往上算）\n\n\n计算完Depth值后，获得材质球Material的InstanceID先进行升序排序，得出以下顺序的List\n\n之后获取TextTure ID的InstanceId，并再进行一次升序排序，最终得到下面顺序的List。\n使用SpriteAltas的图集或者使用Tp打包的图集，TextTure ID就是图集的ID。\n使用单个图片没有图集，TextTrueID就是其本身的ID，说明打包图集可以让元素拥有同一纹理。\n\n决定1次DrawCall就是List中相邻相同的Depth，MaterialID和TextureID，上图的DrawCall是638&#x2F;10138&#x2F;10414&#x2F;638，4个DrawCall。\n如果出现这种情况，就优先从Hieraphy上往上搜寻。\n\n另一情况：PosZ不为0\n当父节点Pos Z 不为0，子节点Pos Z为0时，子节点满足以下条件可合批：\n\n满足图集一致，材质一致等基本条件。\n在Hierarchy相邻。\n跟Depth值以及其他节点是否相交没关系。\n\n当父节点Pos Z为 0，子节点Pos Z不为0时：\n\n父节点下所有子节点都满足合批条件，无论子节点PosZ都可以合批。\n\n父节点下所有子节点都满足基本合批条件（部分图集和材质一致），则合批受Hierarchy的节点顺序影响。\n\n\n\n根据以上规则，就可以得出一些“摆UI”的技巧：\n\n有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。\n要注意UI元素间的层叠关系，建议用“T”工具查看其矩形大小，因为有些图片透明，但是却叠在其它UI上面了，然后又无法Batch的话，就会无故多许多Drawcall；\nUI中出现最多的就是img与Text组件，当Text叠在img上面（如Button)，然后Text上又叠了一个图片时，就会至少多2个Drawcall，可以考虑将字体直接印在下面的图片上；\n有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。\n\n","slug":"UI的DrawCall计算","date":"2022-06-28T08:25:28.000Z","categories_index":"Unity","tags_index":"UI,优化","author_index":"HalfReunion"},{"id":"0b6ba2c8e01bb1370597130d76cb280b","title":"制作一个跑酷系统","content":"1，人物控制和相机控制1：控制相机与角色的偏移transform.position = new Vector3(x,x,x)+ followTarget.position;\n\n2：让相机以角色为中心点，以一个圆为周期转动。\ntransform.position = Quaternion.Euler(x轴转向, y轴转向, 0) * new Vector3(0,0,距离角色距离) \n+ followTarget.position + 中心点的偏移量;\n\ntransform.rotation = Quaternion.Euler(x轴转向, y轴转向, 0)\n\n3：移动和根据相机位置调整方位知识点 : 四元数 * 向量 &#x3D; 旋转后的向量 （注意左右乘）\n//监控按键 0渐变为1或者-1\nfloat h = Input.GetAxis(\"Horizontal\");\nfloat v = Input.GetAxis(\"Vertical\");\n\n//监控按键的量，有值说明有按键\nfloat moveAmount = Mathf.Clamp01(Mathf.Abs(h) + Mathf.Abs(v));\n\n//构建移动向量，注意椭圆映射\nvar moveInput = (new Vector3(\n            h * Mathf.Sqrt(1 - Mathf.Pow(v,2) / 2.0f), \n            0, \n            v * Mathf.Sqrt(1 - Mathf.Pow(h, 2) / 2.0f)));\n\n//获得相机的旋转量 并乘上移动向量，获得旋转后向量\nvar moveDir = cameraController.PlanarRotation * moveInput;\n\n//若有按键\nif (moveAmount > 0) \n        &#123;   //移动\n            transform.position += moveDir * moveSpeed * Time.deltaTime;\n            //保存转动方向\n\t\t\ttargetRotation = Quaternion.LookRotation(moveDir);\n         \n        &#125;\n\n//转动角色朝向\ntransform.rotation= Quaternion.RotateTowards(\ntransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);\n\t\n//设置混合树 \n//dampTime: 用 dampTime 长的时间，将 我们设置的叫做  name 的 float类型 的值由 原本的值 改变到给定的 value 值。\n//deltaTime：两次执行该方法的时间间隔。（因为这个方法会每 deltaTime 执行一次，直到 name = value）\nanimator.SetFloat(Animator.StringToHash(\"NormalAmount\"), moveAmount,0.2f,Time.deltaTime);\n\n\n4：转用CharacterController来控制角色移动CC自带有胶囊碰撞体。一般来说这类东西的组合是Rb+Collider或者单独一个CC。CC适用于第一人称或者第三人称人物角色控制，但是需要自己写一些东西比如重力。\nCharacterController \n1.Character Controller不是基于物理，没有重力，没有阻力，没有加速度，所有移动都是精确的\n\n2.Character Controller可以跨过物体，也就是上台阶，不过会一顿一顿，同是下楼梯需要自己写重力\n\n3.Character Controller 不会对 Rigidbody产生反应\n\n4.Character Controller自带地面监测，不过好像有BUG，一般还是自己写\n\n5.Character Controller的移动通过向量控制，自带碰撞监测\n\nRigidbody\n1.Rigidbody是基于物理的，所以移动会比较平滑自然，但是因为有各种力，所以很难保证精确度\n\n2.Rigidbody会对Rigidbody产生反应\n\n3.Rigidbody的移动通过力或者速度控制，不加碰撞体就不会产生碰撞\n\n\n//transform.position += moveDir * moveSpeed * Time.deltaTime;\n//改成\ncharacterController.Move(moveDir * moveSpeed * Time.deltaTime);\n\n5：使用Physics物理检测检测是否踩在地板上，并且添加重力影响。\n[SerializeField] float groundCheckRadius;\n[SerializeField] Vector3 groundCheckOffset;\n[SerializeField] LayerMask groundLayer;\n[SerializeField] bool isGround;\nGroundCheck(); \n//如果踩在地板上\nif (isGround) \n&#123;\n   ySpeed = -0.5f;\n&#125;else&#123;\n\t//添加一个向下的量，用以模拟重力掉落。\n   ySpeed += Physics.gravity.y ;\n&#125;\nvar velocity = moveDir * moveSpeed;\n\n//添加向下的量\nvelocity.y = ySpeed;\n\n//\ncharacterController.Move(velocity * Time.deltaTime);\n\nprivate void GroundCheck() &#123;\n//射线检测，创建一个球体用来检测\n    isGround = Physics.CheckSphere(transform.TransformPoint(groundCheckOffset) ,\n    groundCheckRadius, \n    groundLayer.value);\n&#125;\n\n\n2.跑酷系统1.墙面扫描设定一个墙面扫描的脚本，用处是扫描人物面前的障碍物。\n对于不同高度的障碍物，需要使用射线扫描面前的障碍物高度，然后根据高度选择播放的动画。\n//前向射线的偏移值\n[SerializeField] Vector3 forwardRayOffset;\n//前向射线长度\n[SerializeField] float forwardRayLength = 0.8f;\n//扫描高度值的射线最大值\n[SerializeField] float heightRayLength = 5f;\n//用于标识障碍物的层\n[SerializeField] LayerMask obstacleLayer;\n\npublic ObstacleHitData ObstacleCheck() \n&#123;\n    var hitData = new ObstacleHitData();\n    var forwardOrigin = transform.position + forwardRayOffset;\n        \n    //前向射线\n    hitData.forwardHitFound = Physics.Raycast(forwardOrigin, \n    transform.forward,\n    out hitData.forwardHit, forwardRayLength,obstacleLayer);\n\n    Debug.DrawRay(forwardOrigin, transform.forward * forwardRayLength,(hitData.forwardHitFound) ?Color.red:Color.white);\n\n    if (hitData.forwardHitFound) &#123;\n        //碰撞点上面往下射,刚好碰到面前物体的边缘,算出障碍物的总高度,需要减去人物最低点才能得到实际高度。\n        var heightOrigin = hitData.forwardHit.point + Vector3.up \n        * heightRayLength;\n\n        hitData.heightHitFound = Physics.Raycast(heightOrigin,Vector3.down,\n        out hitData.heightHit,heightRayLength,obstacleLayer);\n\n        Debug.DrawRay(heightOrigin,Vector3.down * heightRayLength,(hitData.forwardHitFound) ? Color.red : Color.white);\n\n        Debug.Log(hitData.heightHit.point);\n    &#125;\n        return hitData;\n&#125;\n\npublic struct ObstacleHitData &#123;\n    //前向射线是否有碰撞\n    public bool forwardHitFound;\n    //高度射线是否有碰撞\n    public bool heightHitFound;\n    //前向射线\n    public RaycastHit forwardHit;\n    //高度射线\n    public RaycastHit heightHit;\n&#125;\n2.播放动画首先封装一个行为类ParkourAction，继承自ScriptObject，用于存储动画信息和触发动画需要的条件。\n[SerializeField] private  string animName;\n//可播放动画的最低高度\n[SerializeField] private float minHeight;\n//可播放动画的最高高度\n[SerializeField] private float maxHeight;\n\n//是否要角色转向障碍物\n[SerializeField] bool rotateToObstacle;\n\n[Header(\"使用Target Matching\")]\n[SerializeField] bool enabledTargetMatching = true;\n[SerializeField] AvatarTarget matchBodyPart;\n[SerializeField] float matchStartTime;\n[SerializeField] float matchTargetTime;\n\n//存储四元数,里面是射线碰撞到的障碍物的法线方向取反,即角色朝向障碍物面的四元数。\npublic Quaternion TargetRotation &#123; get; set; &#125;\npublic Vector3 MatchPos &#123; get; set; &#125;\n\n//检测条件是否符合播放动画的要求\npublic bool CheckIfPossible(ObstacleHitData hitData, Transform player) &#123;\n    //减去人物的高度得出障碍物的高度\n    float height = hitData.heightHit.point.y - player.position. y;\n    Debug.Log($\"面前的障碍物高度为:&#123;height&#125;\");\n    \n    if (height &lt;= minHeight || height > maxHeight) &#123;\n        return false; \n    &#125;\n\n    if (rotateToObstacle)\n    &#123;\n        \n        TargetRotation = Quaternion.LookRotation(-hitData.forwardHit.normal);\n    &#125;\n       \n    if (enabledTargetMatching) &#123;\n        MatchPos = hitData.heightHit.point;\n    &#125;\n    return true;\n&#125;\n\npublic string AnimName => animName;\npublic bool RotateToObstacle => rotateToObstacle;\n\npublic bool EnabledTargetMatching => enabledTargetMatching;\npublic AvatarTarget MatchBodyPart=> matchBodyPart;\npublic float MatchStartTime => matchStartTime;\npublic float MatchTargetTime => matchTargetTime;\n\n\n对于跨越或者攀爬这种会实际产生模型位移的动画，需要注意Animator的Apply Root Motion和动画Import Setting里Animation的Bake Into Pose，此处需要将Animator组件的Apply Root Motion勾选上。使用协程来执行跨越障碍物的动画，\nIEnumerator DoParkoutAction(ParkourAction action) &#123;\n    //是否在播放动画\n    inAction = true;\n    //角色控制器是否可控\n    playerController.SetControl(false);\n    animator.CrossFade(action.AnimName, 0.1f);\n    //animator.Play(\"StepUp\");\n    yield return null; \n\n    \n    //此函数在过渡期可用,获得下一个动画状态\n    var animState = animator.GetNextAnimatorStateInfo(0);\n    if (!animState.IsName(action.AnimName)) &#123;\n        Debug.Log(\"The parkour animation is wrong\");\n    &#125;\n         \n\n    float timer = 0f;\n    //动画播放中\n    while(timer &lt;= animState.length)\n    &#123;\n        timer += Time.deltaTime;\n\n        if (action.RotateToObstacle) &#123;\n            //转向障碍物\n            transform.rotation = Quaternion.RotateTowards(\n            transform.rotation,\n            action.TargetRotation,\n            playerController.RotationSpeed * Time.deltaTime);\n        &#125;\n\n        //目标匹配,后面再讲\n        if (action.EnabledTargetMatching) &#123;\n            MatchTarget(action);\n        &#125;\n\n        yield return null;\n    &#125;\n\n    //解除锁定\n    inAction = false;\n    playerController.SetControl(true);\n    &#125;\n\n\n3.优化动画出现的问题：\n\n动画在播放结束后，脚部会出现障碍物穿模或者高过障碍物的情况。\n\n有攀墙动作的动画，手部无法真正抓住边缘。\n\n攀爬结束后按前进会导致人物平移一段时间。\n\n攀爬过程中整个人穿模。\n\n\nTarget Matching 目标匹配Unity手册的描述：通常在游戏中可能出现以下情况：角色必须以某种方式移动，使得手或脚在某个时间落在某个地方。例如，角色可能需要跳过踏脚石或跳跃并抓住顶梁。这种情况可以用Target Maching。(似乎只能用在AnimatorController里)\n我们的动画里有跃起，然后踏上障碍体的动作。首先要在AnimationClip里找到动画标准化时间的两个点，1个是角色离地的时间点，1个是踏上障碍体,结束落地的时间点。\nvoid MatchTarget(ParkourAction action) &#123;\n    //是否要使用了目标匹配\n    if (animator.isMatchingTarget) &#123;\n        return;\n    &#125;\n\n    //参数解释：1.需要匹配的位置(一般为障碍物的高度值y,这里为高度射线的碰撞点位置取y值)\n    //2.角色转向的四元数。 3.系统枚举值:要匹配的肢体,人物四肢的其中1个。 4.~。 5.开始匹配的时间点。 6.结束匹配的时间点\n    animator.MatchTarget(action.MatchPos,transform.rotation,\n        action.MatchBodyPart,\n        new MatchTargetWeightMask(new Vector3(0,1,1),0),\n        action.MatchStartTime,\n        action.MatchTargetTime);\n    &#125;\n\n第1点，这时候可以调整,调为feet。\n使用 Feet__ 时，对于所有帧，Root Transform Position Y 将与位置最低的脚 Y 匹配。因此，混合点始终保持在脚周围，从而防止在混合或过渡时发生浮动问题。\n脚超模的现象可以按第2点调。\n第2点，需要调整MatchTarget第4个参数，Unity手册里写的是：包含匹配位置和旋转的权重的结构，使用此结构可为 Animator.MatchTarget 指定位置和旋转权重遮罩。\n有一个Vector3类型的参数positionXYZWeight:位置 XYZ 权重,值在0~1之间。\n一个float类型的参数rotationWeight:\t旋转权重\n这里把positionXYZWeight的z值设为最高值1,这样匹配的权重会偏向障碍物平面的最边缘，可以把这个权重值封装在ScriptObject行为类里。同理把y值设为1,说明在匹配y值方面,会把权重偏向最接近障碍物平面上,这样就不容易出现脚穿模在地下的情况。\n第3点，这里有一点上述的代码里没讲，因为攀爬动作没有从蹲下到站立的动画，所以攀爬结束后混合了一段蹲到站立的动画。而这里是由于使用了Time.deltaTime只等待了一段AnimationClip的播放，没有等待蹲下到站立的部分。这段的解决比较宽泛，可以用yield return 再等待一段时间。\n第4点，这个是因为Match Target的匹配时间点没设好，只能慢慢调了。\n","slug":"制作一个跑酷系统","date":"2022-06-26T11:44:10.000Z","categories_index":"Unity","tags_index":"C#,制作实例,动画系统","author_index":"HalfReunion"},{"id":"df72ebc7475da7a2a818b4e6f4f94099","title":"Time函数和Update和FixedUpdate","content":"Time.timeScale 不会影响Update和LateUpdate的执行速度。\nFixedUpdate是根据Time.time来执行的，所以Time.timeScale会影响到FixedUpdate的执行。\nFixedTimeStep中的设置是指Time.time的时间变化，如果设置为0.02s，则意味着Time.timeScale&#x3D;1的情况下，Time.time的值每过0.02秒就调用一次FixedUpdate。\nTime.deltaTime：表示当前时刻到上一帧所经过的秒数，具体值和当前游戏的帧数有关。Time.deltaTime的值在update上 &#x3D; 1&#x2F;帧率 * Time.timeScale。同时也是Time.time的增量值。 \n所以在Update中进行物体移动的话，需要Time.deltaTime * speed * Vector3方向向量,相当于每秒往Vector3方向移动speed距离。\n\nFixedUpdate，固定的一个时间频率去调整； \nUpdate，根据系统性能的FPS速率有影响关系；\n关于上两条的一些证明\npublic void FixedUpdate()\n    &#123;\n        i++;\n        Debug.Log(\"这在是第\" + i + \"帧\");\n        time += Time.deltaTime;\n        Debug.Log(\"时间：\" + time);\n    &#125;\n\n上面的time值始终是以0.02的量去增长。\nvoid FixedUpdate()\n&#123;\n\tDebug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\nvoid Update()\n&#123;\n\tDebug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n&#125;\n\n经此测试可发现，在帧率较低的情况下，FixedUpdate并不是间隔0.02秒才调用一次，有可能在Update前调用多次，间隔的时间也不一定，当我们设置FixedUpdate的步长为0.02秒（50FPS）时，设置刷新的频率为30FPS，FixedUpdate每秒的调用次数势必要多于Update。\n[SerializeField]\n float time = 0f;\n [SerializeField]\n float Fixedtime = 0f;\nvoid FixedUpdate()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        Debug.Log(\"FixedUpdate realTime: \" + Time.realtimeSinceStartup);\n        Debug.Log(\"FixedUpdate deltaTime: \" + Time.deltaTime);\n        Fixedtime += Time.deltaTime;\n\n    &#125;\n\n    void Update()\n    &#123;\n        if (time >= 1.0f)\n        &#123;\n            return;\n        &#125;\n        time += Time.deltaTime;\n        \n        Debug.LogError(\"Update realTime: \" + Time.realtimeSinceStartup);\n    &#125;\n\n验证两者对于真实时间的联系，设置游戏帧率为10帧，在经过1秒后，二者的增量几乎一致。\n\n已知，Update的调用次数为1秒钟调用帧数次，FixedUpdate设置的步长为0.02。则1&#x2F;0.02 &#x3D; 50FPS。\n\n所以说FixedUpdate固定时间频率是指，会在1秒内调用 （1&#x2F;设置的步长） 次FixedUpdate，而不一定是经过真实时间里 设置的Fixed Step  秒就调用1次，两次FixedUpdate调用的间隔其实是Time.time经过 设置的步长。\n而Update则是根据游戏内的帧率时刻浮动来决定执行次数。\n所以，FixedUpdate除了用来处理物理逻辑之外并不适合处理其他模块的逻辑。\n因为它是用来处理物理模拟的，更重要的是它并非根据真实时间的间隔执行，而只是有一个固定的量。\n关于为何要推荐在FixedUpdate处理物理逻辑：在物理模拟中，保证一个固定的增量时间是十分重要的。这是因为在游戏引擎进行物理模拟时要使用数值积分，而作为最简单的数值积分方法——欧拉法在游戏引擎中大量使用。而在游戏引擎的物理模拟中，一个不稳定的增量时间可能导致很多和预期相悖的结果。\n固定的增量时间作为一个常量参数传递给物理模拟模块，这样我们就能够保证物理模拟的增量时间固定，同时还能将物理模拟的更新频率和游戏引擎的更新频率进行解耦——物理的模拟不受引擎的更新频率影响，无论游戏的更新频率是多少，传递给物理模拟的增量时间都是一个常量。\nOnTrigger，OnCollision系列和FixedUpdate都依赖物理步，也就是Fixed Step来触发。\n而如果将输入检测或者需要每帧检测的逻辑放入物理步中判断就会出错。\n\nTime.timeScale 会影响Time.Time，比如Time.timeScale ＝ 2的话，那么Time.time的增长速度也会变成2倍速度。\n如果你想取到游戏的实际时间，那么使用Time.timeSinceLevelLoad就可以，前提是必须在**Awake()方法以后再取，如果在Awake()**方法里面取Time.realtimeSinceStartup会取出一个错误的值，在Start方法里面取的话就正常了。\n总之一句话Time.timeScale影响的是Unity的游戏时间缩放比例。\nUnity里面所有跟时间有关系的东西都是根据timeScale来演算的。\n仔细想想现在的手游就是个 动画 和 粒子技能特效 还有UI位移特效，所以改他们的速度直接用Time.timeScale就可以完成。还有一个重要的东西就是人物移动 或者 技能移动的速度了，\n 根据时间的公式，时间 ＝ 路程\\速度 ，比如角色从起点跑到中间的一个预期时间， 或者一个技能的火球从攻击到打中目标的预期时间。 凡是处理时间的东东全用Time.time 这样就可以完美让Time.timeScale控制你的游戏了。\n\n有关于LateUpdate的操作，事关摄像机跟随游戏对象时会发生抖动的阐述。\n画面抖动的原因是因为摄像机位置更新与目标(抖动对象)位置更新不同步造成的.\n结论：1）Time.time的每帧的增量即为Time.deltaTime\n2）Time.deltaTime和Time.time都受Time.timeScale影响，且是正比的关系\n3）Time.deltaTime的最大调用时间间隔为Time面板的 Maximum Allowed Timestep 值\n4）Time.realtimeSinceStartup不受Time.timeScale影响，它为真实的游戏时间\n5）Update的调用不受Time.timeScale影响，它的调用间隔和真实的上一帧调用时间有关\n6）LateUpdate的调用同Update，不受Time.timeScale影响（截图时忘了开打印，实际同Update）\n7）FixedUpdate的调用受Time.timeScale影响，且成正比，当Time.timeScale &#x3D; 0时，FixedUpdate不被调用\n8）FixedUpdate的调用时间间隔为Time面板的 Fixed Timestep 值，受Time.time影响。\n\nFixedUpdate在每帧的调用不固定，有可能执行多次，有可能不执行。\n\n总结：1）想让游戏对象受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.time &#x2F; Time.deltaTime 做关联计算并放在Update中更新，或者将它放在FixedUpdate中做更新（使用Time.fixeddeltaTime，或按帧计算）\n2）想让游戏对象不受Time.timeScale（子弹时间）影响时，则将游戏对象和 Time.realtimeSinceStartup 做关联计算并放在Update中更新\n3）Unity中默认Animation、Animator和粒子特效都是受Time.timeScale（子弹时间）影响的\n4）想让Animator不受Time.timeScale（子弹时间）影响时，可以将它的更新模式改为：animator.updateMode &#x3D; AnimatorUpdateMode.UnscaledTime;\n5）想让Animation或粒子特效不受Time.timeScale（子弹时间）影响时，要用Time.realtimeSinceStartup做采样计算，并对它们做更新\n\n额外部分内容的链接https://blog.csdn.net/cube454517408/article/details/107496353\n关于Time相关的例子：\n1，子弹时间（缓慢的粒子特效 或者 只有自己不受影响\n2，定时回调系统\n3，暂停游戏\n设置 Time.timeScale ＝ 0；即可让游戏暂停。 其实我们暂停的主要是 人物动画，还有技能特效，比如一个火球打了一半。\nUI方面往往我们不希望暂停，比如暂停界面 有一些UI位移动画或者帧动画， 或者最起码要有个“取消暂停的按钮” 吧。 总不能游戏暂停了我点击按钮，按钮的点击动画或者特效也暂停了吧。\n所有的动画都是基于时间来的，因为Time.timeScale ＝ 0了，所以Time.time也就不会在变化了。换句话来说如果游戏暂停以后想在暂停界面上继续播放一些不受Time.timeScale 影响的动画，那么我们就需要用到Time.realtimeSinceStartup。\nAnimationState animState = animation[clipName]; // 当前动画状态\nanimation.Play(clipName);//播放动画\ncurTime = Time.realtimeSinceStartup; // 当前真实时间\ndeltaTime = curTime - lastFrameTime; // 此帧与上一帧的时间间隔\nlastFrameTime = curTime; // 记录此帧时间，下一帧用\nprogressTime += deltaTime; // 动画已播放时间\nanimState.normalizedTime = progressTime / currState.length; // 动画规范化时间[0-1]\nanimation.Sample(); // 在当前状态对动画进行采样，当你想显式设置动画状态并且对它取样的时候使用\n\n\n附录： 只读:\nTime.time：表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。Time.deltaTime：表示从上一帧到当前帧的时间，以秒为单位。Time.unscaleddeltaTime：不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。Time.timeSinceLevelLoad：表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。Time.unscaledTime：不考虑timescale时候与time相同，若timescale被设置，则无效。Time.fixeddeltaTime：表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&gt;ProjectSettings-&gt;Time的Fixed Timestep可以自行设置。Time.realtimeSinceStartup： 表示自游戏开始后的总时间，即使暂停也会不断的增加。Time.frameCount：总帧数\n 可读可写:\nTime.fixedTime：表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixeddeltaTime）直到达到time属性。Time.SmoothdeltaTime：表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。Time.timeScale：时间缩放，默认值为1，若设置&lt;1，表示时间减慢，若设置&gt;1,表示时间加快，可以用来加速和减速游戏，非常有用。Time.captureFramerate：表示设置每秒的帧率，然后不考虑真实时间。 \n\n帧数显示器和设置游戏整体帧率的代码：\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FPS : MonoBehaviour\n&#123;\n    private float m_LastUpdateShowTime = 0f;  //上一次更新帧率的时间;  \n\n    private float m_UpdateShowdeltaTime = 0.01f;//更新帧率的时间间隔;  \n\n    private int m_FrameUpdate = 0;//帧数;  \n\n    private float m_FPS = 0;\n\n    void Awake()\n    &#123;\n\t\t\t\t//设置帧率\n        Application.targetFrameRate = 30;\n    &#125;\n\n    // Use this for initialization  \n    void Start()\n    &#123;\n        m_LastUpdateShowTime = Time.realtimeSinceStartup;\n    &#125;\n\n    // Update is called once per frame  \n    void Update()\n    &#123;\n        m_FrameUpdate++;\n        if (Time.realtimeSinceStartup - m_LastUpdateShowTime >= m_UpdateShowdeltaTime)\n        &#123;\n            m_FPS = m_FrameUpdate / (Time.realtimeSinceStartup - m_LastUpdateShowTime);\n            m_FrameUpdate = 0;\n            m_LastUpdateShowTime = Time.realtimeSinceStartup;\n        &#125;\n    &#125;\n\n    void OnGUI()\n    &#123;\n        GUIStyle labelFont = new GUIStyle();\n        labelFont.fontSize = 20;\n        GUI.Label(new Rect(Screen.width / 2, 0, 100, 100), \"FPS: \" + m_FPS, labelFont);\n    &#125;\n&#125;\n\n关于deltaTime比较粗浅的解释：https://www.cnblogs.com/jiangxiaoming/p/12983807.html\n","slug":"Time函数和Update和FixedUpdate","date":"2022-06-26T08:17:29.000Z","categories_index":"Unity","tags_index":"探索发现,C#,Api","author_index":"HalfReunion"}]