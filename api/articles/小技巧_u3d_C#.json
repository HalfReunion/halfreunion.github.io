{"title":"小技巧_u3d_C#","uid":"9f9e7828b8716ddb566b45d44fabc1de","slug":"小技巧_u3d_C#","date":"2022-06-28T09:02:08.000Z","updated":"2022-06-28T09:06:21.788Z","comments":true,"path":"api/articles/小技巧_u3d_C#.json","keywords":null,"cover":"/img/background/cover.jpg","content":"<p>1，使用Physics.OverlapSphereNonAlloc，不会像Physics.OverlapSphere那样创建出Collider[]数组出来，它生成的是一个int值类型，这意味着就不会分配内存空间，不会产生GC，很多检测都有NonAlloc，有些情况可以考虑使用这些OverLapXXXNonAlloc。</p>\n<p>2，对于两个脚本间互相调用，会遇到start与start间初始化时间存在乱序而空引用的错误，此时可以用访问器解决，</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">xxx <span class=\"token class-name\">xx</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>_xx<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\t_xx <span class=\"token operator\">=</span> <span class=\"token generic-method\"><span class=\"token function\">GetComponent</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>xxx<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token keyword\">return</span> _xx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3，yield return new 产生的GC问题。可以生成一个静态对象解决。</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">YieldHelper</span>\n<span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">WaitForEndOfFrame</span> WaitForEndOfFrame <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">WaitForEndOfFrame</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token return-type class-name\">IEnumerator</span> <span class=\"token function\">WaitForSeconds</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">float</span></span> totalTime<span class=\"token punctuation\">,</span><span class=\"token class-name\"><span class=\"token keyword\">bool</span></span> ignoreTimeScale <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token class-name\"><span class=\"token keyword\">float</span></span> time <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>time <span class=\"token operator\">&lt;</span> totalTime<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t\ttime <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span>ignoreTimeScale<span class=\"token punctuation\">?</span>Time<span class=\"token punctuation\">.</span>unscaledDeltaTime<span class=\"token punctuation\">:</span>Time<span class=\"token punctuation\">.</span>deltaTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t  <span class=\"token keyword\">yield</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4，enum : byte 的作用<br>这个表示枚举元素使用 byte 存储。<br>普通声明的话，是继承int。例 public enum Icon_Type : int<br>继承自byte可以稍微减少一点内存占用。</p>\n<p>5，对比int比对比string效率更高，所以有些地方可以考虑用将字符串转化为哈希值再对比。当然可能有哈希冲突的风险。</p>\n","text":"1，使用Physics.OverlapSphereNonAlloc，不会像Physics.OverlapSphere那样创建出Collider[]数组出来，它生成的是一个int值类型，这意味着就不会分配内存空间，不会产生GC，很多检测都有NonAlloc，有些情况可以考虑使用这些...","link":"","photos":[],"count_time":{"symbolsCount":898,"symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":7,"path":"api/categories/Unity.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}],"toc":"","author":{"name":"HalfReunion","slug":"blog-author","avatar":"/img/icon/avatar.jpg","link":"/","description":"如无必要，勿增实体","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"UnityEngine.Object和System.Object","uid":"0eeec1440f5c3f42f857474d88fef113","slug":"UnityEngine-Object和System-Object","date":"2022-06-29T03:32:19.000Z","updated":"2022-06-29T03:35:50.893Z","comments":true,"path":"api/articles/UnityEngine-Object和System-Object.json","keywords":null,"cover":"/img/background/cover.jpg","text":"引子 string s = string.Empty; var go = new GameObject(\"goodBoy\"); DestroyImmediate(go); go = null; if (!go) s += \"A\"; if (go is null) s += \"B\"...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Unity","slug":"Unity","count":7,"path":"api/categories/Unity.json"}],"tags":[{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"},{"name":"基础","slug":"基础","count":2,"path":"api/tags/基础.json"}],"author":{"name":"HalfReunion","slug":"blog-author","avatar":"/img/icon/avatar.jpg","link":"/","description":"如无必要，勿增实体","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"UI的DrawCall计算","uid":"1350894a588790266d2094e5ec7bddd0","slug":"UI的DrawCall计算","date":"2022-06-28T08:25:28.000Z","updated":"2022-06-28T09:12:09.631Z","comments":true,"path":"api/articles/UI的DrawCall计算.json","keywords":null,"cover":"/img/background/cover.jpg","text":"总结提取自uwa4d的文章：https://edu.uwa4d.com/course-intro/0/126 影响DrawCall的元素有三点：Depth值，Material，Texture。 Depth值： 需要按照Hierarchy面板的节点顺序，从上到下进行Depth分析。...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":7,"path":"api/categories/Unity.json"}],"tags":[{"name":"UI","slug":"UI","count":2,"path":"api/tags/UI.json"},{"name":"优化","slug":"优化","count":1,"path":"api/tags/优化.json"}],"author":{"name":"HalfReunion","slug":"blog-author","avatar":"/img/icon/avatar.jpg","link":"/","description":"如无必要，勿增实体","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}